/********************* ROLES **********************/

/********************* UDFS ***********************/

DECLARE EXTERNAL FUNCTION UDF_ABS
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Abs'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ACOS
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_ACos'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_AGE
Timestamp
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Age'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_AGE2
Timestamp, Timestamp
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Age2'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_AND
Integer, Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_And'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ANSILOWER
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_AnsiLower'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ANSIUPPER
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_AnsiUpper'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ASIN
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_ASin'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ATAN
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_ATan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_CEIL
Double precision
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Ceil'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_CHR
CSTRING(1), Smallint
RETURNS PARAMETER 1
ENTRY_POINT 'udf_Chr'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_COLLATEBR
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_CollateBr'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_COPY
CSTRING(254), Integer, Integer
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Copy'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_COS
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Cos'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_COTAN
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_CoTan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DAY
Timestamp
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Day'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DAYFRAC
Timestamp
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_DayFrac'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DAYNAME
CSTRING(15), Timestamp
RETURNS PARAMETER 1
ENTRY_POINT 'udf_DayName'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DAYSBETWEEN
Timestamp, Timestamp
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_DaysBetween'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DAYSPAN
Timestamp, Timestamp
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_DaySpan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DEGTORAD
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_DegToRad'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DIGITS
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Digits'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DIV
Integer, Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Div'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_DZERO
Double precision, Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_DZero'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ENCDATE
Timestamp, Smallint, Smallint, Smallint
RETURNS PARAMETER 1
ENTRY_POINT 'udf_EncDate'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ENCTIME
Timestamp, Smallint, Smallint, Smallint
RETURNS PARAMETER 1
ENTRY_POINT 'udf_EncTime'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ENCTS
Timestamp, Smallint, Smallint, Smallint, Smallint, Smallint, Smallint
RETURNS PARAMETER 1
ENTRY_POINT 'udf_EncTS'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_EXP
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Exp'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_FACTORIAL
Integer
RETURNS Numeric(18,0) BY VALUE 
ENTRY_POINT 'udf_Factorial'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_FLOOR
Double precision
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Floor'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_FRAC
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Frac'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_GETBIT
Integer, Smallint
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_GetBit'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_HEXTOINT
CSTRING(20)
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_HexToInt'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_HOUR
Timestamp
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Hour'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_HOURSBETWEEN
Timestamp, Timestamp
RETURNS Numeric(18,0) BY VALUE 
ENTRY_POINT 'udf_HoursBetween'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_HOURSPAN
Timestamp, Timestamp
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_HourSpan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_HYPOT
Double precision, Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Hypot'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCDATE
Timestamp, Integer, Integer, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncDate'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCDAY
Timestamp, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncDay'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCHOUR
Timestamp, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncHour'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCMINUTE
Timestamp, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncMinute'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCMONTH
Timestamp, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncMonth'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCSECOND
Timestamp, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncSecond'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCTIME
Timestamp, Integer, Integer, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncTime'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCTS
Timestamp, Integer, Integer, Integer, Integer, Integer, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncTS'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCWEEK
Timestamp, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncWeek'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INCYEAR
Timestamp, Integer
RETURNS Timestamp
ENTRY_POINT 'udf_IncYear'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INT
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Int'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_INTTOHEX
CSTRING(20), Integer, Integer
RETURNS PARAMETER 1
ENTRY_POINT 'udf_IntToHex'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ISALPHA
CSTRING(254)
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_IsAlpha'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ISDIGIT
CSTRING(254)
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_IsDigit'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ISLOWER
CSTRING(254)
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_IsLower'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ISUPPER
CSTRING(254)
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_IsUpper'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LASTDAY
Smallint, Smallint
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_LastDay'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LEFT
CSTRING(254), Integer
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Left'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LEN
CSTRING(254)
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Len'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LNXP1
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_LnXP1'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LOG10
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Log10'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LOG2
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Log2'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LOGN
Double precision, Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_LogN'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LOWER
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Lower'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_LTRIM
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_LTrim'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MAX
Double precision, Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Max'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MAXDATE
Timestamp, Timestamp
RETURNS Timestamp
ENTRY_POINT 'udf_MaxDate'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MAXTIME
Timestamp, Timestamp
RETURNS Timestamp
ENTRY_POINT 'udf_MaxTime'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MAXTS
Timestamp, Timestamp
RETURNS Timestamp
ENTRY_POINT 'udf_MaxTS'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MIN
Double precision, Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Min'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MINDATE
Timestamp, Timestamp
RETURNS Timestamp
ENTRY_POINT 'udf_MinDate'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MINTIME
Timestamp, Timestamp
RETURNS Timestamp
ENTRY_POINT 'udf_MinTime'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MINTS
Timestamp, Timestamp
RETURNS Timestamp
ENTRY_POINT 'udf_MinTS'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MINUTE
Timestamp
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Minute'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MINUTESBETWEEN
Timestamp, Timestamp
RETURNS Numeric(18,0) BY VALUE 
ENTRY_POINT 'udf_MinutesBetween'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MINUTESPAN
Timestamp, Timestamp
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_MinuteSpan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MOD
Integer, Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Mod'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MONTH
Timestamp
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Month'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MONTHEND
Timestamp, Smallint, Smallint
RETURNS PARAMETER 1
ENTRY_POINT 'udf_MonthEnd'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MONTHNAME
CSTRING(15), Timestamp
RETURNS PARAMETER 1
ENTRY_POINT 'udf_MonthName'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MONTHSBETWEEN
Timestamp, Timestamp
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_MonthsBetween'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MONTHSPAN
Timestamp, Timestamp
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_MonthSpan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_MONTHSTART
Timestamp, Smallint, Smallint
RETURNS PARAMETER 1
ENTRY_POINT 'udf_MonthStart'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_NOT
Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Not'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_NVL
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_NVL'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ODD
Integer
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Odd'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_OR
Integer, Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Or'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ORD
CSTRING(254)
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Ord'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_PADL
CSTRING(254), CSTRING(254), Integer
RETURNS CSTRING(254)
ENTRY_POINT 'udf_PadL'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_PADR
CSTRING(254), CSTRING(254), Integer
RETURNS CSTRING(254)
ENTRY_POINT 'udf_PadR'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_PI

RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Pi'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_POS
CSTRING(254), CSTRING(254)
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Pos'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_POWER
Double precision, Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Power'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_RADTODEG
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_RadToDeg'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_RAND

RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Rand'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_RANDINT
Integer, Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_RandInt'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_REPEAT
CSTRING(254), CSTRING(254), Integer
RETURNS PARAMETER 1
ENTRY_POINT 'udf_Repeat'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_REPLACE
CSTRING(254), CSTRING(254), CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Replace'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_RIGHT
CSTRING(254), Integer
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Right'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ROUND
Double precision
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Round'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_ROUNDDEC
Double precision, Smallint
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_RoundDec'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_RTRIM
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_RTrim'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SDAYNAME
CSTRING(5), Timestamp
RETURNS PARAMETER 1
ENTRY_POINT 'udf_SDayName'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SECOND
Timestamp
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Second'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SECONDSBETWEEN
Timestamp, Timestamp
RETURNS Numeric(18,0) BY VALUE 
ENTRY_POINT 'udf_SecondsBetween'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SECONDSPAN
Timestamp, Timestamp
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_SecondSpan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SETBIT
Integer, Smallint, Smallint
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_SetBit'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SHL
Integer, Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_ShL'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SHR
Integer, Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_ShR'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SIGN
Double precision
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Sign'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SIN
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Sin'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SMONTHNAME
CSTRING(5), Timestamp
RETURNS PARAMETER 1
ENTRY_POINT 'udf_SMonthName'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SPACE
CSTRING(254), Integer
RETURNS PARAMETER 1
ENTRY_POINT 'udf_Space'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SQR
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Sqr'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_SQRT
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Sqrt'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_STRIP
CSTRING(254), CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Strip'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_STROFCHR
CSTRING(254), CSTRING(1), Integer
RETURNS PARAMETER 1
ENTRY_POINT 'udf_StrOfChr'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_STRZERO
CSTRING(20), Integer, Integer
RETURNS PARAMETER 1
ENTRY_POINT 'udf_StrZero'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_STUFF
CSTRING(254), Integer, Integer, CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Stuff'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_TAN
Double precision
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Tan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_TRIM
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Trim'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_TRUNC
Double precision
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Trunc'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_TRUNCDEC
Double precision, Smallint
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_TruncDec'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_UPPER
CSTRING(254)
RETURNS CSTRING(254)
ENTRY_POINT 'udf_Upper'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_VER

RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_Ver'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_WEEKDAY
Timestamp
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_WeekDay'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_WEEKSBETWEEN
Timestamp, Timestamp
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_WeeksBetween'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_WEEKSPAN
Timestamp, Timestamp
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_WeekSpan'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_XOR
Integer, Integer
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_Xor'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_YEAR
Timestamp
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_Year'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_YEARDAY
Timestamp
RETURNS Smallint BY VALUE 
ENTRY_POINT 'udf_YearDay'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_YEARSBETWEEN
Timestamp, Timestamp
RETURNS Integer BY VALUE 
ENTRY_POINT 'udf_YearsBetween'
MODULE_NAME 'tbudf';

DECLARE EXTERNAL FUNCTION UDF_YEARSPAN
Timestamp, Timestamp
RETURNS Double precision BY VALUE 
ENTRY_POINT 'udf_YearSpan'
MODULE_NAME 'tbudf';

/****************** GENERATORS ********************/

CREATE GENERATOR GENIDCONFIGURACAO;
CREATE GENERATOR GENIDITEMPERFIL;
CREATE GENERATOR GENIDLOGOPERACAO;
CREATE GENERATOR GENIDLOG_AGENDA;
CREATE GENERATOR GENIDLOG_ALIQUOTAS;
CREATE GENERATOR GENIDMENSAGEM;
/******************** DOMAINS *********************/

CREATE DOMAIN "BOOLEAN"
 AS Char(1)
 CHECK (VALUE IN ('S', 'N') OR VALUE IS NULL)
 COLLATE ISO8859_1;
CREATE DOMAIN BOOLEANINT
 AS Integer
 CHECK (VALUE IN (0, 1) OR VALUE IS NULL)
;
CREATE DOMAIN CEP
 AS Varchar(10)
 COLLATE ISO8859_1;
CREATE DOMAIN CMC7
 AS Varchar(35)
 COLLATE ISO8859_1;
CREATE DOMAIN CNPJCPF
 AS Varchar(20)
 COLLATE ISO8859_1;
CREATE DOMAIN CODIGOBARRA
 AS Varchar(13)
 COLLATE ISO8859_1;
CREATE DOMAIN CREDITODEBITO
 AS Char(1)
 CHECK (VALUE IN ('C', 'D'))
 COLLATE ISO8859_1;
CREATE DOMAIN DATA
 AS Date
;
CREATE DOMAIN DATAHORA
 AS Timestamp
;
CREATE DOMAIN DATAVALIDADE
 AS Varchar(10)
 COLLATE ISO8859_1;
CREATE DOMAIN DESCRICAOCURTA
 AS Varchar(20)
 COLLATE ISO8859_1;
CREATE DOMAIN DESCRICAOLONGA
 AS Varchar(250)
 COLLATE ISO8859_1;
CREATE DOMAIN DESCRICAOMEDIA
 AS Varchar(80)
 COLLATE ISO8859_1;
CREATE DOMAIN ESTADO
 AS Char(2)
 COLLATE ISO8859_1;
CREATE DOMAIN IMAGEM
 AS Blob sub_type 0
;
CREATE DOMAIN INTEIRO
 AS Integer
;
CREATE DOMAIN LOGIN
 AS Varchar(10)
 COLLATE ISO8859_1;
CREATE DOMAIN MOEDA
 AS Numeric(13,4)
;
CREATE DOMAIN MSG
 AS Varchar(255)
 COLLATE ISO8859_1;
CREATE DOMAIN PARAMCHAR
 AS Char(1)
 COLLATE ISO8859_1;
CREATE DOMAIN RG
 AS Varchar(25)
 COLLATE ISO8859_1;
CREATE DOMAIN SENHA
 AS Varchar(10)
 COLLATE ISO8859_1;
CREATE DOMAIN SERIAL
 AS Varchar(20)
 COLLATE ISO8859_1;
CREATE DOMAIN SUPER_TEXTO
 AS Varchar(1000)
 COLLATE ISO8859_1;
CREATE DOMAIN TELEFONE
 AS Varchar(20)
 COLLATE ISO8859_1;
CREATE DOMAIN TEXTO
 AS Blob sub_type 1
;
CREATE DOMAIN TEXTO_250
 AS Blob sub_type 1
;
CREATE DOMAIN VALOR
 AS Float
;
/******************* PROCEDURES ******************/

SET TERM ^ ;
CREATE PROCEDURE STPABRELOGOPERACAO (
    ORIGEM Varchar(80),
    USUARIO Varchar(10) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPBAIXACOMPRA (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPBAIXAVENDA (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPCAIXASPADRAO (
    ID Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPCONFIGPADRAO (
    COMPUTADOR Varchar(80),
    DIREXP Varchar(150) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPDELCAIXA (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPDELCP (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPDELCR (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPDELDUPLICATA (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPDELETQPRODUTO (
    CODIGO Varchar(13) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPDELORCAMENTO (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPDELVENDA (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPDESMARCAPROMOCAO
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPESTORNACOMPRA (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPESTORNAVENDA (
    CODIGO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPFECHALOGOPERACAO
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPGETCLIENTEANIVER (
    TIPO Integer,
    DIAINI Integer,
    DIAFIM Integer,
    MES Integer,
    ANO Integer,
    DATA1 Date,
    DATA2 Date )
RETURNS (
    NOME Varchar(50),
    DATANASC Date,
    ENDERECO Varchar(50),
    CIDADE Varchar(50),
    BAIRRO Varchar(50),
    CEP Varchar(20),
    FONE Varchar(20) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPGETID (
    FIELDNAME Varchar(31),
    TABLENAME Varchar(31) )
RETURNS (
    ID Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPINSCAIXA (
    CONTA Integer,
    DATA Date,
    DESCRICAO Varchar(80),
    DOCUMENTO Varchar(20),
    TIPO Char(1),
    VALOR Numeric(13,4) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPINSCHEQUE (
    PIDBANCO Integer,
    PIDCLIENTE Integer,
    PIDFORN Integer,
    PBANDAMAGNETICA Varchar(35),
    PAGENCIA Varchar(20),
    PCONTA Varchar(20),
    PNUMERO Varchar(20),
    PDATAEMISSAO Date,
    PBOMPARA Date,
    PVALOR Numeric(13,4),
    PVENDA Integer,
    PCOMPRA Integer,
    PREPASSADO Char(1),
    PDATABAIXADO Date )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPPAGTOCOMPRA (
    IDCOMPRA Integer,
    DATAPAGTO Date,
    FORMAPAGTO Varchar(20),
    VALORPAGO Numeric(13,2) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPPRODUTOSVENCIDOS (
    DATAVENC Date,
    IDUN Integer,
    IDGRUPO Integer,
    IDFORNECEDOR Integer )
RETURNS (
    CODBARRA Varchar(13),
    PRODUTO Varchar(50),
    DATAVENCIMENTO Date,
    UNIDADE Varchar(20),
    GRUPO Varchar(50),
    FORNECEDOR Varchar(50),
    PRECOCUSTO Numeric(13,2) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPRECTOVENDA (
    IDVENDA Integer,
    DATARECTO Date,
    FORMARECTO Varchar(20),
    VALORRECDO Numeric(13,2) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPRELCAIXAMESANO (
    MES Integer,
    ANO Integer,
    PORDEM Char(1) )
RETURNS (
    CODIGO Integer,
    DATA Date,
    DESCRICAO Varchar(80),
    DOCUMENTO Varchar(20),
    TIPO Char(1),
    VALOR Numeric(13,2),
    TOTALCREDITOS Numeric(13,2),
    TOTALDEBITOS Numeric(13,2),
    TOTALSALDO Numeric(13,2),
    TOTAL Numeric(13,2) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPRELCAIXATIPOCONTA (
    PDATAINI Date,
    PDATAFIM Date,
    PTIPOCONTA Char(1),
    PORDEM Char(1) )
RETURNS (
    CODIGO Integer,
    TOTAL Numeric(13,2),
    DATA Date,
    DESCRICAO Varchar(80),
    DOCUMENTO Varchar(20),
    TIPO Char(1),
    VALOR Numeric(13,2) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPRESTOCOMPRA (
    PIDCOMPRA Integer )
RETURNS (
    RESTO Numeric(13,2) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPRESTOVENDA (
    PIDVENDA Integer )
RETURNS (
    RESTO Numeric(13,2) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPSITUACAOCLIENTE (
    CODIGO Integer )
RETURNS (
    CLIENTE Varchar(80),
    LIMITECLIENTE Numeric(13,2),
    DATACADASTRO Date,
    TOTALCONTAS Numeric(13,2),
    TOTALCONTASVENCIDAS Numeric(13,2),
    PRIMEIROVENCIMENTO Date,
    DIASATRASO Integer )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE STPVENDACOMISSAO (
    VENDEDOR Integer,
    DATAINI Date,
    DATAFIM Date )
RETURNS (
    CODPRODUTO Integer,
    DESCRICAO Varchar(150),
    QTD Integer,
    TOTAL Numeric(13,2),
    COMISSAO Numeric(13,2) )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

/******************** TABLES **********************/

CREATE TABLE AGENDA
(
  IDAGENDA INTEIRO NOT NULL,
  NOME DESCRICAOMEDIA,
  TELEFONE TELEFONE,
  TELEFONE2 TELEFONE,
  TELEFONE3 TELEFONE,
  FAX TELEFONE,
  OBS TEXTO,
  CONSTRAINT PK_AGENDA PRIMARY KEY (IDAGENDA)
);
CREATE TABLE ALIQUOTAS
(
  CODALIQUOTA INTEIRO NOT NULL,
  DESCRICAO DESCRICAOCURTA,
  CONSTRAINT PK_ALIQUOTAS PRIMARY KEY (CODALIQUOTA)
);
CREATE TABLE BANCO
(
  IDBANCO INTEIRO NOT NULL,
  BANCO DESCRICAOMEDIA,
  CONSTRAINT PK_BANCO PRIMARY KEY (IDBANCO)
);
CREATE TABLE CAIXA
(
  CODCAIXA INTEIRO NOT NULL,
  CODCAIXAS INTEIRO NOT NULL,
  DATA DATA,
  DESCRICAO DESCRICAOMEDIA,
  DOCUMENTO DESCRICAOCURTA,
  TIPO CREDITODEBITO,
  VALOR MOEDA,
  EXCLUIR "BOOLEAN",
  CONSTRAINT PK_CAIXA PRIMARY KEY (CODCAIXA)
);
CREATE TABLE CAIXAS
(
  CODIGO INTEIRO NOT NULL,
  NOME DESCRICAOMEDIA,
  INATIVO "BOOLEAN",
  CONSTRAINT PK_CAIXAS PRIMARY KEY (CODIGO)
);
CREATE TABLE CFOP
(
  NUMERO DESCRICAOCURTA NOT NULL,
  OPERACAO DESCRICAOLONGA,
  CFNOTA SUPER_TEXTO,
  CONSTRAINT PK_CFOP PRIMARY KEY (NUMERO)
);
CREATE TABLE CHEQUE
(
  IDCHEQUE INTEIRO NOT NULL,
  IDBANCO INTEIRO,
  IDCLIENTE INTEIRO,
  IDFORN INTEIRO,
  BANDAMAGNETICA CMC7,
  AGENCIA DESCRICAOMEDIA,
  CONTA DESCRICAOCURTA,
  NUMERO DESCRICAOCURTA,
  DATAEMISSAO DATA,
  BOMPARA DATA,
  VALOR MOEDA,
  VENDA INTEIRO,
  COMPRA INTEIRO,
  REPASSADO "BOOLEAN",
  DATABAIXADO DATA,
  CONSTRAINT PK_CHEQUE PRIMARY KEY (IDCHEQUE)
);
CREATE TABLE CIDADES
(
  CODCIDADE INTEIRO NOT NULL,
  DESCRICAO DESCRICAOMEDIA,
  CONSTRAINT PK_CIDADES PRIMARY KEY (CODCIDADE)
);
CREATE TABLE CLIENTES
(
  CODCLIENTE INTEIRO NOT NULL,
  TIPO PARAMCHAR,
  NOME DESCRICAOMEDIA,
  ENDERECO DESCRICAOMEDIA,
  CEP CEP,
  BAIRRO DESCRICAOMEDIA,
  TELEFONE TELEFONE,
  FAX TELEFONE,
  CODCIDADE INTEIRO,
  UF ESTADO,
  TEMPO_MORADIA DESCRICAOMEDIA,
  END_ANTERIOR DESCRICAOMEDIA,
  E_MAIL DESCRICAOMEDIA,
  TRABALHO DESCRICAOMEDIA,
  CARGO DESCRICAOMEDIA,
  DATA_INICIO DATA,
  SALARIO MOEDA,
  ESTADO_CIVIL PARAMCHAR,
  CONJUGUE DESCRICAOMEDIA,
  LOCAL_TRAB DESCRICAOMEDIA,
  DATA_NASC DATA,
  PAI DESCRICAOMEDIA,
  MAE DESCRICAOMEDIA,
  CPF_CNPJ CNPJCPF,
  RG_IE DESCRICAOCURTA,
  REFER_PES DESCRICAOLONGA,
  REFER_COM DESCRICAOLONGA,
  FONE_COM TELEFONE,
  CADASTRO DATA,
  OBS TEXTO,
  NATURALIDADE DESCRICAOMEDIA,
  LIMITE MOEDA,
  FOTO IMAGEM,
  CONSTRAINT PK_CLIENTES PRIMARY KEY (CODCLIENTE)
);
CREATE TABLE CONFIGDUPLICATA
(
  CAMPO DESCRICAOMEDIA,
  VERTICAL INTEIRO,
  HORIZONTAL INTEIRO,
  FONTE INTEIRO,
  NOMECAMPO DESCRICAOMEDIA,
  TIPOFONTE DESCRICAOMEDIA,
  ESTILOFONTE DESCRICAOMEDIA
);
CREATE TABLE CONFIGNOTA
(
  CODIGO INTEIRO NOT NULL,
  CAMPO DESCRICAOMEDIA,
  LAYOUT DESCRICAOMEDIA,
  REFERENCIA DESCRICAOMEDIA,
  TIPO PARAMCHAR,
  LINHA INTEIRO,
  COLUNA INTEIRO,
  IMPRIMIR "BOOLEAN",
  CONSTRAINT PK_CONFIGNOTA PRIMARY KEY (CODIGO)
);
CREATE TABLE CONFIGURACAO
(
  IDCONFIGURACAO INTEIRO NOT NULL,
  NOMECOMPUTADOR DESCRICAOMEDIA,
  BARRAFERRAMENTA "BOOLEAN",
  HINTBALAO "BOOLEAN",
  GRAVAERRO "BOOLEAN",
  BACKUP "BOOLEAN",
  LOG "BOOLEAN",
  IMPRESSORA "BOOLEAN",
  RESOLUCAO "BOOLEAN",
  LETRACODIGOBARRA "BOOLEAN",
  EXIBEDICADIA "BOOLEAN",
  AVISACLIENTEATRASO "BOOLEAN",
  DIREXPORTPADRAO DESCRICAOLONGA,
  SENHAESTOQUE SENHA,
  USARSENHAESTOQUE "BOOLEAN",
  ESTOQUEPADRAO INTEIRO,
  BORDAETQPROD "BOOLEAN",
  ALIQUOTAPADRAO INTEIRO NOT NULL,
  DESCPADRAOPROD MOEDA,
  CAIXAPADRAO INTEIRO NOT NULL,
  SENHACAIXA SENHA,
  PRODSEMESTOQORCAM "BOOLEAN",
  ORCAMNAOCONC "BOOLEAN",
  EDITORCAMCONC "BOOLEAN",
  COMPRANAOCONC "BOOLEAN",
  EDITCOMPRACONC "BOOLEAN",
  PRODSEMESTOQVENDA "BOOLEAN",
  VENDANAOCONC "BOOLEAN",
  EDITVENDACONC "BOOLEAN",
  BORDAETQCLIENTE "BOOLEAN",
  MOSTRARSALDOCAIXA "BOOLEAN",
  CAIXA90DIAS "BOOLEAN",
  RELZEBRADO "BOOLEAN",
  VERIFICA_UPD "BOOLEAN",
  CONTACHEQUE INTEIRO,
  INFOAVISOS "BOOLEAN",
  CONSTRAINT PK_CONFIGURACAO PRIMARY KEY (IDCONFIGURACAO)
);
CREATE TABLE CONFIGURACAOGLOBAL
(
  TAXAJURO MOEDA,
  INTERVALO INTEIRO,
  PRAZOINICIAL INTEIRO,
  PARCELAS INTEIRO,
  LIMITECLIENTE MOEDA,
  TITULOORCAM DESCRICAOMEDIA,
  COLUNAORCAMBOBINA INTEIRO,
  MSGRODAPEORCAM DESCRICAOLONGA,
  TITULOVENDA DESCRICAOMEDIA,
  COLUNAVENDABOBINA INTEIRO,
  MSGRODAPEVENDA DESCRICAOLONGA,
  LINHAPULARBOBINAVENDA INTEIRO,
  LINHAPULARBOBINAORCAM INTEIRO,
  PORTAIMPVENDA DESCRICAOCURTA,
  FTP_HOST DESCRICAOMEDIA,
  FTP_USER_NAME DESCRICAOMEDIA,
  FTP_PASSWORD DESCRICAOMEDIA,
  FTP_TIMEOUT INTEIRO,
  FTP_PASSIVE "BOOLEAN",
  FTP_DIR DESCRICAOMEDIA,
  IDADECADASTROCLIENTE INTEIRO,
  IDCONFIGGLOBAL INTEIRO NOT NULL,
  CONSTRAINT PK_CONFIGURACAOGLOBAL PRIMARY KEY (IDCONFIGGLOBAL)
);
CREATE TABLE CONTASPAGAR
(
  CODIGO INTEIRO NOT NULL,
  DATA DATA,
  VENCIMENTO DATA,
  DESCRICAO DESCRICAOMEDIA,
  FORNECEDOR INTEIRO,
  VALOR MOEDA,
  DOCUMENTO DESCRICAOCURTA,
  PAGAR "BOOLEAN",
  JURO MOEDA,
  PAGA "BOOLEAN",
  DATAPAGTO DATA,
  ORIGEM INTEIRO,
  COMPRA INTEIRO,
  CAPITALPAGO MOEDA,
  JUROPAGO MOEDA,
  DESCTO MOEDA,
  OBS TEXTO,
  IDCONTA INTEIRO,
  CONSTRAINT PK_CONTASPAGAR PRIMARY KEY (CODIGO)
);
CREATE TABLE CONTASRECEBER
(
  CODIGO INTEIRO NOT NULL,
  DATA DATA,
  VENCIMENTO DATA,
  CLIENTE INTEIRO,
  DESCRICAO DESCRICAOMEDIA,
  DOCUMENTO DESCRICAOCURTA,
  VALOR MOEDA,
  JURO MOEDA,
  RECEBER "BOOLEAN",
  RECDA "BOOLEAN",
  DATARECTO DATA,
  ORIGEM INTEIRO,
  VENDA INTEIRO,
  CAPITALRECDO MOEDA,
  JURORECDO MOEDA,
  DESCTO MOEDA,
  OBS TEXTO,
  IDCONTA INTEIRO,
  CONSTRAINT PK_CONTASRECEBER PRIMARY KEY (CODIGO)
);
CREATE TABLE DUPLICATA
(
  IDDUPLICATA INTEIRO NOT NULL,
  NRODUPLICATA DESCRICAOCURTA,
  SACADO DESCRICAOMEDIA,
  CPF_CNPJ CNPJCPF,
  ENDERECO DESCRICAOMEDIA,
  BAIRRO DESCRICAOMEDIA,
  CEP CEP,
  IDCIDADE INTEIRO,
  FONEFAX TELEFONE,
  UF ESTADO,
  IE DESCRICAOCURTA,
  DATAEMISSAO DATA,
  NROFATURA DESCRICAOCURTA,
  VALOR_FATURA MOEDA,
  VALOR MOEDA,
  DATAVENC DATA,
  DESCONTO MOEDA,
  PRACAPAGAMENTO DESCRICAOLONGA,
  DATADESCTO DATA,
  VALOREXTENSO DESCRICAOLONGA,
  DATAIMPRESSAO DATA,
  IMPRESSA "BOOLEAN",
  CONSTRAINT PK_DUPLICATA PRIMARY KEY (IDDUPLICATA)
);
CREATE TABLE EMPRESA
(
  FANTAZIA DESCRICAOMEDIA,
  RAZASOCIAL DESCRICAOMEDIA,
  CNPJ CNPJCPF,
  IE DESCRICAOCURTA,
  IM DESCRICAOCURTA,
  ENDERECO DESCRICAOMEDIA,
  IDCIDADE INTEIRO,
  BAIRRO DESCRICAOMEDIA,
  CEP CEP,
  TELEFONE TELEFONE,
  FAX TELEFONE,
  UF ESTADO,
  RESPONSAVEL DESCRICAOMEDIA,
  LOGOEMPRESA IMAGEM,
  EMAIL DESCRICAOLONGA
);
CREATE TABLE ENVELOPE
(
  IDENVELOPE INTEIRO NOT NULL,
  NOME DESCRICAOMEDIA,
  ENDERECO DESCRICAOMEDIA,
  IDCIDADE INTEIRO,
  BAIRRO DESCRICAOMEDIA,
  CEP CEP,
  MENSAGEM DESCRICAOLONGA,
  CONSTRAINT PK_ENVELOPE PRIMARY KEY (IDENVELOPE)
);
CREATE TABLE ETIQUETA
(
  IDETIQUETA INTEIRO NOT NULL,
  ETIQUETA DESCRICAOMEDIA,
  ALTURAFOLHA VALOR,
  LARGURAFOLHA VALOR,
  MARGEMSUPERIOR VALOR,
  MARGEMESQUERDA VALOR,
  NUMEROLINHAS INTEIRO,
  NUMEROCOLUNAS INTEIRO,
  ALTURAETIQUETA VALOR,
  LARGURAETIQUETA VALOR,
  DISTANCIAVERTICAL VALOR,
  DISTANCIAHORIZONTAL VALOR,
  DISTACOLVERTICAL VALOR,
  DISTCOLHORIZ VALOR,
  CONSTRAINT PK_ETIQUETA PRIMARY KEY (IDETIQUETA)
);
CREATE TABLE ETIQUETAPROD
(
  IDETIQUETAPROD INTEIRO NOT NULL,
  CODBARRA CODIGOBARRA,
  DESCRICAO DESCRICAOMEDIA,
  PRECO MOEDA,
  CONSTRAINT PK_ETIQUETAPROD PRIMARY KEY (IDETIQUETAPROD)
);
CREATE TABLE FORNECEDORES
(
  CODFORNECEDOR INTEIRO NOT NULL,
  FANTAZIA DESCRICAOMEDIA,
  RAZAOSOCIAL DESCRICAOMEDIA,
  DATACAD DATA,
  ENDERECO DESCRICAOMEDIA,
  CIDADE INTEIRO,
  BAIRRO DESCRICAOMEDIA,
  CNPJ CNPJCPF,
  IE DESCRICAOCURTA,
  CEP CEP,
  TELEFONE TELEFONE,
  FAX TELEFONE,
  EMAIL DESCRICAOMEDIA,
  UF ESTADO,
  OBS TEXTO,
  VENDEDOR DESCRICAOMEDIA,
  TELEFONEVENDEDOR TELEFONE,
  EMAILVENDEDOR DESCRICAOMEDIA,
  TIPO PARAMCHAR,
  CONSTRAINT PK_FORNECEDORES PRIMARY KEY (CODFORNECEDOR)
);
CREATE TABLE GRUPOS
(
  CODGRUPO INTEIRO NOT NULL,
  DESCRICAO DESCRICAOMEDIA,
  CONSTRAINT PK_GRUPOS PRIMARY KEY (CODGRUPO)
);
CREATE TABLE ITEMNOTAFISCAL
(
  NUMERO INTEIRO NOT NULL,
  PRODUTO INTEIRO,
  ALIQUOTA INTEIRO,
  QTDE INTEIRO,
  TOTAL MOEDA,
  CUSTO MOEDA,
  LUCRO INTEIRO,
  VENDA MOEDA,
  IPI MOEDA,
  DESCONTO MOEDA
);
CREATE TABLE ITEMORCAMENTO
(
  CODIGO INTEIRO NOT NULL,
  CODPRODUTO INTEIRO,
  QTDE INTEIRO,
  CUSTO MOEDA,
  VENDA MOEDA,
  DESCTO MOEDA,
  VALORDESCTO MOEDA,
  TOTAL MOEDA
);
CREATE TABLE ITEMPERFIL
(
  IDITEMPERFIL INTEIRO NOT NULL,
  IDPERFIL INTEIRO NOT NULL,
  ACAO_NOME DESCRICAOMEDIA,
  ACAO_CAPTION DESCRICAOMEDIA,
  LIBERADO "BOOLEAN",
  CONSTRAINT PK_ITEMPERFIL PRIMARY KEY (IDITEMPERFIL)
);
CREATE TABLE ITEMVENDA
(
  CODIGO INTEIRO NOT NULL,
  CODPRODUTO INTEIRO,
  QTD INTEIRO,
  CUSTO MOEDA,
  VENDA MOEDA,
  DESCTO MOEDA,
  VALORDESCTO MOEDA,
  TOTAL MOEDA,
  COMISSAO MOEDA,
  VALORCOMISSAO MOEDA
);
CREATE TABLE LOGERRO
(
  IDLOGERRO INTEIRO NOT NULL,
  DATAHORA DATAHORA,
  FORM DESCRICAOMEDIA,
  CONTROLE DESCRICAOMEDIA,
  MSG DESCRICAOLONGA,
  CONSTRAINT PK_LOGERRO PRIMARY KEY (IDLOGERRO)
);
CREATE TABLE LOGOPERACAO
(
  IDLOGOPERACAO INTEIRO NOT NULL,
  IDCONNECTION INTEIRO,
  ORIGEM DESCRICAOMEDIA,
  USUARIO LOGIN,
  DATAHORA DATAHORA,
  ABERTO BOOLEANINT,
  CONSTRAINT PK_LOGOPERACAO PRIMARY KEY (IDLOGOPERACAO)
);
CREATE TABLE LOG_AGENDA
(
  IDLOG_AGENDA INTEIRO NOT NULL,
  TIPOOPERACAO PARAMCHAR,
  USUARIO LOGIN,
  DATAHORA DATAHORA,
  IDLOGOPERACAO INTEIRO,
  IDAGENDA INTEIRO,
  NOME DESCRICAOMEDIA,
  TELEFONE TELEFONE,
  FAX TELEFONE,
  CONSTRAINT PK_LOG_AGENDA PRIMARY KEY (IDLOG_AGENDA)
);
CREATE TABLE LOG_ALIQUOTAS
(
  IDLOG_ALIQUOTAS INTEIRO NOT NULL,
  TIPOOPERACAO PARAMCHAR,
  USUARIO LOGIN,
  DATAHORA DATAHORA,
  IDLOGOPERACAO INTEIRO,
  CODALIQUOTA INTEIRO,
  DESCRICAO DESCRICAOCURTA,
  CONSTRAINT PK_LOG_ALIQUOTAS PRIMARY KEY (IDLOG_ALIQUOTAS)
);
CREATE TABLE MENSAGEM
(
  IDMENSAGEM INTEIRO NOT NULL,
  MENSAGEM MSG,
  DATA_CADASTRO DATA,
  TIPO PARAMCHAR,
  IDWEB INTEIRO,
  CONSTRAINT PK_MENSAGEM PRIMARY KEY (IDMENSAGEM)
);
CREATE TABLE NOTAS_FISCAIS
(
  NUMERO INTEIRO NOT NULL,
  CODFORNECEDOR INTEIRO,
  DATANOTA DATA,
  DATAENTRADA DATA,
  CFOP DESCRICAOCURTA,
  DESCONTO MOEDA,
  ICMS MOEDA,
  IPI MOEDA,
  FRETE MOEDA,
  DESPESAS MOEDA,
  TOTALPRODUTO MOEDA,
  TOTAL MOEDA,
  OBS TEXTO,
  BAIXADO "BOOLEAN",
  CONCLUIDA "BOOLEAN",
  CANCELADO "BOOLEAN",
  CONSTRAINT PK_NOTAS_FISCAIS PRIMARY KEY (NUMERO)
);
CREATE TABLE ORCAMENTO
(
  CODIGO INTEIRO NOT NULL,
  IDVENDEDOR INTEIRO,
  CODCLIENTE INTEIRO,
  DATA DATA,
  OBS DESCRICAOLONGA,
  TOTAL MOEDA,
  ITENS INTEIRO,
  STATUS PARAMCHAR,
  CONCLUIDO "BOOLEAN",
  CONSTRAINT PK_ORCAMENTO PRIMARY KEY (CODIGO)
);
CREATE TABLE PAGTOCOMPRA
(
  IDPAGTOCOMPRA INTEIRO NOT NULL,
  IDCOMPRA INTEIRO,
  DATAPAGTO DATA,
  FORMAPAGTO DESCRICAOCURTA,
  VALORPAGO MOEDA,
  VALORRESTO MOEDA,
  CONSTRAINT PK_PAGTOCOMPRA PRIMARY KEY (IDPAGTOCOMPRA)
);
CREATE TABLE PERDA
(
  CODIGO INTEIRO NOT NULL,
  CODPRODUTO INTEIRO,
  QTDE INTEIRO,
  PRECO MOEDA,
  DATA DATA,
  MOTIVO PARAMCHAR,
  OBS TEXTO,
  CONSTRAINT PK_PERDA PRIMARY KEY (CODIGO)
);
CREATE TABLE PERFIL
(
  IDPERFIL INTEIRO NOT NULL,
  PERFIL DESCRICAOMEDIA,
  CONSTRAINT PK_PERFIL PRIMARY KEY (IDPERFIL)
);
CREATE TABLE PRODUTOS
(
  IDPRODUTO INTEIRO NOT NULL,
  CODBARRA CODIGOBARRA,
  REFERENCIA DESCRICAOCURTA,
  CODFORNECEDOR INTEIRO,
  CODGRUPO INTEIRO,
  DESCRICAO DESCRICAOMEDIA,
  ABREVIACAO DESCRICAOMEDIA,
  DATAVALIDADE DATA,
  CODUNIDADE INTEIRO,
  PESO MOEDA,
  PRECO_PROMOCAO MOEDA,
  CUSTO MOEDA,
  LUCRO MOEDA,
  VENDA MOEDA,
  ESTOQUE INTEIRO,
  ESTOQUEMINIMO INTEIRO,
  IDALIQUOTA INTEIRO,
  NOVO BOOLEANINT,
  ALTERADO BOOLEANINT,
  QTDERECEBIDA INTEIRO,
  DATARECEBIDA DATA,
  EXCLUIR "BOOLEAN",
  PROMOCAO "BOOLEAN",
  OBS TEXTO,
  CONSTRAINT PK_PRODUTOS PRIMARY KEY (IDPRODUTO)
);
CREATE TABLE PROMOCAO
(
  CODIGO INTEIRO NOT NULL,
  PRODUTO INTEIRO NOT NULL,
  DESCONTO MOEDA,
  PRECO MOEDA,
  INICIO DATA,
  FIM DATA,
  CONSTRAINT PK_PROMOCAO PRIMARY KEY (CODIGO),
  CONSTRAINT UN_PROMOCAO_PRODUTO UNIQUE (PRODUTO)
);
CREATE TABLE RECIBO
(
  IDRECIBO INTEIRO NOT NULL,
  DATA DATA,
  RECEBEDOR DESCRICAOLONGA,
  REFERENTE TEXTO,
  VALOR MOEDA,
  VALOREXTENSO TEXTO,
  CONSTRAINT PK_RECIBO PRIMARY KEY (IDRECIBO)
);
CREATE TABLE RECTOVENDA
(
  IDRECTOVENDA INTEIRO NOT NULL,
  IDVENDA INTEIRO,
  DATARECTO DATA,
  FORMARECTO DESCRICAOCURTA,
  VALORRECDO MOEDA,
  VALORRESTO MOEDA,
  CONSTRAINT PK_RECTOVENDA PRIMARY KEY (IDRECTOVENDA)
);
CREATE TABLE SISTEMA
(
  IDSISTEMA INTEIRO DEFAULT 1 NOT NULL,
  VERSAO DESCRICAOCURTA,
  DATAVALIDADE DATAVALIDADE,
  DATA_ACESSO DATAVALIDADE,
  SERIAL SERIAL,
  HD DESCRICAOCURTA,
  CONSTRAINT PK_SISTEMA PRIMARY KEY (IDSISTEMA)
);
CREATE TABLE UNIDADES
(
  CODUNIDADE INTEIRO NOT NULL,
  DESCRICAO DESCRICAOCURTA,
  CONSTRAINT PK_UNIDADES PRIMARY KEY (CODUNIDADE)
);
CREATE TABLE USUARIOS
(
  IDUSUARIOS INTEIRO NOT NULL,
  NOME DESCRICAOMEDIA,
  LOGIN LOGIN NOT NULL,
  SENHA SENHA,
  IDPERFIL INTEIRO,
  CONSTRAINT PK_USUARIOS PRIMARY KEY (IDUSUARIOS)
);
CREATE TABLE VENDA
(
  CODIGO INTEIRO NOT NULL,
  IDVENDEDOR INTEIRO,
  CODCLIENTE INTEIRO,
  DATA DATA,
  OBS DESCRICAOLONGA,
  TOTALDESCTO MOEDA,
  TOTAL MOEDA,
  CONCLUIDA "BOOLEAN",
  BAIXADO "BOOLEAN",
  CANCELADO "BOOLEAN",
  CONSTRAINT PK_VENDA PRIMARY KEY (CODIGO)
);
CREATE TABLE VENDEDOR
(
  IDVENDEDOR INTEIRO NOT NULL,
  VENDEDOR DESCRICAOMEDIA,
  ATIVO "BOOLEAN",
  CONSTRAINT PK_VENDEDOR PRIMARY KEY (IDVENDEDOR)
);
/********************* VIEWS **********************/

CREATE VIEW VIEWAGENDA (NOME, TELEFONE, TELEFONE2, TELEFONE3, FAX)
AS 
select
    AG.NOME,
    AG.TELEFONE,
    AG.TELEFONE2,
    AG.TELEFONE3,
    AG.FAX
  from AGENDA AG;
CREATE VIEW VIEWCAIXA (CODIGO, CONTA_CAIXA, DATA, HISTORICO, DOCUMENTO, TIPO, VALOR)
AS 
SELECT
    C.CODCAIXA, 
    CS.NOME,
    C.DATA,
    C.DESCRICAO,
    C.DOCUMENTO,
    C.TIPO,
    C.VALOR
  FROM CAIXA C
  LEFT JOIN CAIXAS CS ON (CS.CODIGO = C.CODCAIXAS)
;
CREATE VIEW VIEWCAIXAS (IDCAIXAS, CAIXANOME, INATIVO)
AS 
select
    CODIGO,
    NOME,
    INATIVO
from CAIXAS
;
CREATE VIEW VIEWCAIXASATIVOS (CODIGO, NOME)
AS 
SELECT
    CS.CODIGO,
    CS.NOME
  FROM CAIXAS CS
  WHERE CS.INATIVO <> 'S'
;
CREATE VIEW VIEWCHEQUE (CODIGO, BANCO, NOME, BANDAMAGNETICA, AGENCIA, CONTA, NUMERO, DATAEMISSAO, BOMPARA, VALOR)
AS 
SELECT
    CQ.IDCHEQUE, 
    B.BANCO,
    CASE WHEN CQ.REPASSADO = 'S' THEN
      F.RAZAOSOCIAL
    ELSE
      C.NOME
    END,
    CQ.BANDAMAGNETICA,
    CQ.AGENCIA,
    CQ.CONTA,
    CQ.NUMERO,
    CQ.DATAEMISSAO,
    CQ.BOMPARA,
    CQ.VALOR
FROM CHEQUE CQ
LEFT JOIN BANCO B ON (B.IDBANCO = CQ.IDBANCO)
LEFT JOIN CLIENTES C ON (C.CODCLIENTE = CQ.IDCLIENTE)
LEFT JOIN FORNECEDORES F ON (F.CODFORNECEDOR = CQ.IDFORN)
;
CREATE VIEW VIEWEMPRESA (RAZAOSOCIAL, CNPJ, IE, ENDERECO, CIDADE, BAIRRO, CEP, TELEFONE, FAX, UF, RESPONSAVEL, LOGOEMPRESA, EMAIL)
AS 
SELECT
      e.RAZASOCIAL,
      e.CNPJ,
      e.IE,
      e.ENDERECO,
      c.Descricao,
      e.BAIRRO,
      e.CEP,
      e.TELEFONE,
      e.FAX,
      e.UF,
      e.RESPONSAVEL,
      e.Logoempresa,
      e.EMAIL
    FROM EMPRESA e
    LEFT JOIN CIDADES c on (e.Idcidade = c.Codcidade)
;
CREATE VIEW VIEWENDERECOCLIENTES (CODIGO, NOME, DATA, ENDERECO, CODCIDADE, CIDADE, BAIRRO, CEP)
AS 
SELECT
    C.CODCLIENTE,
    C.NOME,
    C.DATA_NASC,
    C.ENDERECO,
    C.CODCIDADE,
    CD.DESCRICAO,
    C.BAIRRO,
    C.CEP
  FROM CLIENTES C
  LEFT JOIN CIDADES CD ON (CD.CODCIDADE = C.CODCIDADE);
CREATE VIEW VIEWETIQUETACLIENTE (IDCLIENTE, IDCIDADE, TITULO, TEXTO)
AS 
select
    cli.CODCLIENTE,
    cli.CODCIDADE,
    cli.NOME TITULO,
    cli.ENDERECO || udf_chr(13) ||
    cli.BAIRRO || udf_chr(13) ||
    cid.DESCRICAO || udf_chr(13) ||
    cli.CEP TEXTO
  from CLIENTES cli
  left join CIDADES cid on (cid.CODCIDADE = cli.CODCLIENTE)
;
CREATE VIEW VIEWFICHACLIENTE (CODIGO, TIPO, NOME, ENDERECO, CEP, BAIRRO, TELEFONE, FAX, CODCIDADE, CIDADE, ESTADO, TEMPO_MORADIA, ENDERECO_ANTERIOR, EMAIL, TRABALHO, CARGO, DATA_INICIO, SALARIO, LIMITE, ESTADO_CIVIL, CONJUGUE, LOCAL_TRABALHO, DATA_NASCIMENTO, PAI, MAE, CPF_CNPJ, RG_IE, REFER_PESSOAL, REFER_COMERCIAL, FONE_COMERCIAL, DATA_CADASTRO, NATURALIDADE)
AS 
SELECT
    CLI.CODCLIENTE,
    CLI.TIPO, 
    CLI.NOME, 
    CLI.ENDERECO,
    CLI.CEP,
    CLI.BAIRRO,
    CLI.TELEFONE,
    CLI.FAX,
    CID.CODCIDADE,
    CID.DESCRICAO,
    CLI.UF, 
    CLI.TEMPO_MORADIA,
    CLI.END_ANTERIOR,
    CLI.E_MAIL,
    CLI.TRABALHO,
    CLI.CARGO,
    CLI.DATA_INICIO,
    CLI.SALARIO,
    CLI.LIMITE,
    CLI.ESTADO_CIVIL,
    CLI.CONJUGUE,
    CLI.LOCAL_TRAB,
    CLI.DATA_NASC,
    CLI.PAI,
    CLI.MAE,
    CLI.CPF_CNPJ,
    CLI.RG_IE,
    CLI.REFER_PES,
    CLI.REFER_COM,
    CLI.FONE_COM,
    CLI.CADASTRO,
    CLI.NATURALIDADE
FROM CLIENTES CLI
LEFT JOIN CIDADES CID ON(CLI.CODCIDADE = CID.CODCIDADE)
;
CREATE VIEW VIEWFK (FK, TABELA)
AS 
select
  rrc.RDB$CONSTRAINT_NAME,
  rrc.RDB$RELATION_NAME
from RDB$RELATION_CONSTRAINTS rrc
where upper(rrc.RDB$CONSTRAINT_TYPE) = 'FOREIGN KEY'
;
CREATE VIEW VIEWFORNECEDORES (CODIGO, FANTASIA, RAZAO_SOCIAL, DATA_CADASTRO, ENDERECO, CIDADE, BAIRRO, CNPJ, IE, CEP, TELEFONE, FAX, EMAIL, UF, VENDEDOR, FONE_VENDEDOR, EMAIL_VENDEDOR)
AS 
  SELECT
    f.codfornecedor,
    f.fantazia,
    f.razaosocial,
    f.datacad,
    f.endereco,
    c.descricao,
    f.bairro, 
    f.cnpj,
    f.ie, 
    f.cep, 
    f.telefone,
    f.fax,
    f.email,
    f.uf, 
    f.vendedor,
    f.telefonevendedor,
    f.emailvendedor
  from fornecedores f
  left join cidades c on (f.cidade = c.codcidade)
;
CREATE VIEW VIEWITEMVENDA (CODVENDA, CODPRODUTO, PRODUTO, QTDE, DESCTO, PRECO, TOTAL)
AS 
  SELECT
    IV.CODIGO,
    IV.CODPRODUTO,
    PRO.DESCRICAO,
    UDF_ROUND(IV.QTD),
    IV.DESCTO,
    IV.VENDA,
    IV.TOTAL
  FROM ITEMVENDA IV
  LEFT JOIN PRODUTOS PRO ON (PRO.IDPRODUTO = IV.CODPRODUTO)
;
CREATE VIEW VIEWPERDAS (CODIGO, CODPRODUTO, PRODUTO, QUANTIDADE, PRECO, DATA, MOTIVO)
AS 
  SELECT
    PRD.CODIGO,
    PRD.CODPRODUTO,
    PROD.DESCRICAO,
    PRD.QTDE,
    PRD.PRECO,
    PRD.DATA,
    PRD.MOTIVO
  FROM PERDA PRD
  LEFT JOIN PRODUTOS PROD ON(PRD.CODPRODUTO = PROD.IDPRODUTO)
;
CREATE VIEW VIEWPESQUISAFONE (NOME, TELEFONE, FAX)
AS 
SELECT
    CAST(CLI.NOME AS VARCHAR(100)) NOME,
    CAST(CLI.TELEFONE AS VARCHAR(30)) TELEFONE,
    CAST(CLI.FAX AS VARCHAR(30)) FAX
  FROM CLIENTES CLI
  WHERE (CLI.TELEFONE <> '') OR (CLI.FAX <> '')

  UNION

  SELECT
    CAST(FORN.FANTAZIA AS VARCHAR(100)) NOME,
    CAST(FORN.TELEFONE AS VARCHAR(30)) TELEFONE,
    CAST(FORN.FAX AS VARCHAR(30))FAX
  FROM FORNECEDORES FORN
  WHERE (FORN.TELEFONE <> '') OR (FORN.FAX <> '')

  UNION

  SELECT
    CAST(AG.NOME AS VARCHAR(100)) NOME,
    CAST(AG.TELEFONE AS VARCHAR(30)) TELEFONE,
    CAST(AG.FAX AS VARCHAR(30)) FAX
  FROM AGENDA AG
  WHERE (AG.TELEFONE <> '') OR (AG.FAX <> '')
;
CREATE VIEW VIEWPESQUISAPRECO (CODIGO, CODIGOBARRA, REFERENCIA, DESCRICAO, ESTOQUE, PRECO, FORNECEDOR, GRUPO)
AS 
SELECT
    P.IDPRODUTO,
    P.CODBARRA,
    P.REFERENCIA,
    P.DESCRICAO,
    P.ESTOQUE,
    P.VENDA,
    F.FANTAZIA,
    G.DESCRICAO
  FROM PRODUTOS P
  LEFT JOIN FORNECEDORES F ON (P.CODFORNECEDOR = F.CODFORNECEDOR)
  LEFT JOIN GRUPOS G ON (P.CODGRUPO = G.CODGRUPO)
;
CREATE VIEW VIEWPK (PK, TABELA)
AS 
select
  rrc.RDB$CONSTRAINT_NAME,
  rrc.RDB$RELATION_NAME
from RDB$RELATION_CONSTRAINTS rrc
where upper(rrc.RDB$CONSTRAINT_TYPE) = 'PRIMARY KEY'
;
CREATE VIEW VIEWPRODUTOSMINIMOS (COD_BARRA, PRO_DESCRICAO, PRO_ESTOQUE, QTDE_MINIMA, CODFORNECEDOR, FORNECEDOR)
AS 
SELECT PROD.CODBARRA,
       PROD.DESCRICAO,
       PROD.ESTOQUE,
       PROD.ESTOQUEMINIMO,
       FRN.CODFORNECEDOR,
       FRN.FANTAZIA
FROM PRODUTOS PROD
LEFT JOIN FORNECEDORES FRN ON (FRN.CODFORNECEDOR =  PROD.CODFORNECEDOR)
WHERE (PROD.ESTOQUE <= PROD.ESTOQUEMINIMO)
;
CREATE VIEW VIEWRELCAIXA (CODIGO, DATA, DESCRICAO, DOCUMENTO, TIPO, VALOR)
AS 
  SELECT
     CX.CODCAIXA,
     CX.DATA,
     CX.DESCRICAO,
     CX.DOCUMENTO,
     CX.TIPO,
     CX.VALOR
  FROM CAIXA CX
;
CREATE VIEW VIEWRELCAIXACAIXAS (JAN, FEV, MAR, ABR, MAI, JUN, JUL, AGO, SEP, OUT, NOV, DEZ, NOME, SOMA)
AS 
  SELECT
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 1 THEN CX.VALOR ELSE 0 END) JAN,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 2 THEN CX.VALOR ELSE 0 END) FEV,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 3 THEN CX.VALOR ELSE 0 END) MAR,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 4 THEN CX.VALOR ELSE 0 END) ABR,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 5 THEN CX.VALOR ELSE 0 END) MAI,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 6 THEN CX.VALOR ELSE 0 END) JUN,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 7 THEN CX.VALOR ELSE 0 END) JUL,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 8 THEN CX.VALOR ELSE 0 END) AGO,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 9 THEN CX.VALOR ELSE 0 END) SEP,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 10 THEN CX.VALOR ELSE 0 END) OUT,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 11 THEN CX.VALOR ELSE 0 END) NOV,
      SUM(CASE WHEN UDF_MONTH(CX.DATA) = 12 THEN CX.VALOR ELSE 0 END) DEZ,
      SUM(CX.VALOR) SOMA,
      CXS.NOME
  FROM CAIXA CX
  LEFT JOIN CAIXAS CXS ON (CX.CODCAIXAS = CXS.CODIGO)
  GROUP BY CXS.NOME
;
CREATE VIEW VIEWRELCAIXATODOS (CODIGO, CAIXA, DATA, DESCRICAO, DOCUMENTO, TIPO, VALOR)
AS 
   SELECT
     CX.CODCAIXA,
     CXS.NOME,
     CX.DATA,
     CX.DESCRICAO,
     CX.DOCUMENTO,
     CX.TIPO,
     CX.VALOR
   FROM CAIXA CX
   LEFT JOIN CAIXAS CXS ON (CXS.CODIGO = CX.CODCAIXAS)
;
CREATE VIEW VIEWRELCLIENTES (CODIGO, NOME, ENDERECO, CPF_CNPJ, RG_IE, DATANASCIMENTO, CODCIDADE, CIDADE, TELEFONE, TIPO)
AS 
SELECT
    CLI.CODCLIENTE,
    CLI.NOME,
    CLI.ENDERECO,
    CLI.CPF_CNPJ,
    CLI.RG_IE,
    CLI.DATA_NASC,
    CID.CODCIDADE,
    CID.DESCRICAO,
    CLI.TELEFONE,
    CLI.TIPO
  FROM CLIENTES CLI
  INNER JOIN CIDADES CID ON(CLI.CODCIDADE = CID.CODCIDADE);
CREATE VIEW VIEWRELCP (CODIGO, DATA, VENCIMENTO, CODFORN, FORNECEDOR, DOCUMENTO, VALOR)
AS 
SELECT
    CP.Codigo,
    CP.DATA,
    CP.VENCIMENTO,
    CP.Fornecedor,
    FRN.FANTAZIA,
    CP.DOCUMENTO,
    CP.VALOR
  FROM CONTASPAGAR CP
  left JOIN FORNECEDORES FRN ON (FRN.Codfornecedor = CP.FORNECEDOR)
;
CREATE VIEW VIEWRELCPATRASADOS (CODIGO, DATA, VENCIMENTO, CODFORN, FORNECEDOR, DOCUMENTO, VALOR)
AS 
SELECT
    CP.Codigo,
    CP.DATA,
    CP.VENCIMENTO,
    CP.Fornecedor,
    FRN.FANTAZIA,
    CP.DOCUMENTO,
    CP.VALOR
  FROM CONTASPAGAR CP
  INNER JOIN FORNECEDORES FRN ON (FRN.Codfornecedor = CP.FORNECEDOR)
  WHERE CP.vencimento < current_date AND (CP.Paga = 'N')
;
CREATE VIEW VIEWRELCR (CODIGO, DATA, VENCIMENTO, CLIENTE, CAPITAL, TOTAL)
AS 
  SELECT
    CR.Codigo, 
    CR.DATA,
    CR.VENCIMENTO,
    CLI.NOME,
    CR.VALOR,
    CR.TOTAL
  FROM CONTASRECEBER CR
  LEFT JOIN CLIENTES CLI ON (CLI.Codcliente = CR.CLIENTE)
;
CREATE VIEW VIEWRELCRATRASADOS (CODIGO, VENCIMENTO, CODCLIENTE, CLIENTE, CAPITAL, DIASATRASO, TOTAL)
AS 
  SELECT
    CR.Codigo,
    CR.VENCIMENTO,
    CR.Cliente,
    CLI.Nome,
    CR.VALOR,
    CR.ATRASO,
    CR.TOTAL
  FROM CONTASRECEBER CR
  INNER JOIN CLIENTES CLI ON (CR.CLIENTE = CLI.CODCLIENTE)
  WHERE CR.VENCIMENTO < CURRENT_DATE AND (CR.Recda = 'N')
;
CREATE VIEW VIEWRELFORN (CODIGO, DATA, FANTAZIA, CNPJ, ENDERECO, CIDADE, TELEFONE)
AS 
SELECT
    FRN.CODFORNECEDOR,
    FRN.DATACAD,
    FRN.FANTAZIA,
    FRN.CNPJ,
    FRN.ENDERECO,
    cid.Descricao,
    FRN.TELEFONE
  FROM FORNECEDORES FRN
  left join CIDADES cid on (frn.Cidade = cid.Codcidade)
;
CREATE VIEW VIEWRELNPCR (CODIGO, DATA, VENCIMENTO, CODCLIENTE, CLIENTE, CAPITAL, TOTAL)
AS 
SELECT
    cr.CODIGO,
    cr.DATA,
    cr.VENCIMENTO,
    cr.CLIENTE,
    cli.NOME,
    cr.VALOR,
    cr.TOTAL
from CONTASRECEBER cr
left join CLIENTES cli on (CR.CLIENTE = cli.CODCLIENTE)
;
CREATE VIEW VIEWRELPRODUTOS (IDPRODUTO, CODBARRA, DESCRICAO, CODFORNECEDOR, FORNECEDOR, CODGRUPO, GRUPO, CUSTO, LUCRO, PRECO, ESTOQUE, VALORESTOQUE, NOVO, ALTERADO)
AS 
SELECT
    PROD.Idproduto,
    PROD.CODBARRA,
    PROD.DESCRICAO,
    prod.Codfornecedor,
    frn.Fantazia,
    prod.CODGRUPO,
    G.DESCRICAO,
    PROD.CUSTO,
    PROD.LUCRO,
    PROD.VENDA,
    PROD.ESTOQUE,
    PROD.VALOR_ESTOQUE,
    PROD.NOVO,
    PROD.ALTERADO
  FROM PRODUTOS PROD
  LEFT JOIN GRUPOS G ON(G.CODGRUPO = PROD.CODGRUPO)
  left join FORNECEDORES frn on (frn.Codfornecedor = prod.Codfornecedor)
;
CREATE VIEW VIEWVENDA (CODIGO, DATA, CODVENDEDOR, VENDEDOR, CODCLIENTE, CLIENTE, CPF_CNPJ, CEPCLIENTE, CIDADECLIENTE, FONECLIENTE, ENDERECOCLIENTE, TOTALDESCTO, TOTAL)
AS 
select
    V.CODIGO,
    V.DATA,
    V.IDVENDEDOR,
    VD.VENDEDOR,
    V.CODCLIENTE,
    CLI.NOME,
    CLI.CPF_CNPJ,
    CLI.CEP, 
    CID.DESCRICAO,
    CLI.TELEFONE,
    CLI.ENDERECO,
    V.TOTALDESCTO,
    V.TOTAL
  FROM VENDA V
  LEFT JOIN VENDEDOR VD ON (VD.IDVENDEDOR = V.IDVENDEDOR)
  LEFT JOIN CLIENTES CLI ON (CLI.CODCLIENTE = V.CODCLIENTE)
  LEFT JOIN CIDADES CID ON (CLI.CODCIDADE = CID.CODCIDADE)
;
/******************* EXCEPTIONS *******************/

CREATE EXCEPTION EXC_EXCLUSAO_PERFIL
'No  permitida a excluso deste perfil';
CREATE EXCEPTION EXC_EXCLUSAO_REGISTRO
'No  permitido excluir este registro pois ele  padro.';
CREATE EXCEPTION EXC_INCLUSAO_REGISTRO
'No  permitido incluir registros nesta tabela.';
/******************** TRIGGERS ********************/

SET TERM ^ ;
CREATE TRIGGER TRGLOG_AGENDA_ID FOR LOG_AGENDA ACTIVE
BEFORE INSERT POSITION 0
AS 
BEGIN
  NEW.IDLOG_AGENDA = GEN_ID(GENIDLOG_AGENDA, 1);
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRGLOG_ALIQUOTAS_ID FOR LOG_ALIQUOTAS ACTIVE
BEFORE INSERT POSITION 0
AS 
BEGIN
  NEW.IDLOG_ALIQUOTAS = GEN_ID(GENIDLOG_ALIQUOTAS, 1);
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRGLOG_DELAGENDA FOR AGENDA ACTIVE
AFTER DELETE POSITION 100
AS 
DECLARE VARIABLE IDLOGOPER INTEGER;
DECLARE VARIABLE USUARIO VARCHAR(10);
BEGIN
  /* Se houver log aberto para a conexo corrente ento vincula a operao
     a esse log, do contrrio a varivel ser NULL e o log no vinculado. */
  SELECT MAX(IDLOGOPERACAO), USUARIO
    FROM LOGOPERACAO
   WHERE IDCONNECTION = CURRENT_CONNECTION AND ABERTO = 1
   GROUP BY USUARIO
    INTO :IDLOGOPER, :USUARIO;

  IF (:IDLOGOPER IS NOT NULL) THEN
  BEGIN
    INSERT INTO LOG_AGENDA (
      TIPOOPERACAO,
      USUARIO,
      DATAHORA,
      IDLOGOPERACAO,
      IDAGENDA,
      NOME,
      TELEFONE,
      FAX
      )
    VALUES (
      'D',
      :USUARIO,
      CURRENT_TIMESTAMP,
      :IDLOGOPER,
      OLD.IDAGENDA,
      OLD.NOME,
      OLD.TELEFONE,
      OLD.FAX
      );
  END
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRGLOG_DELALIQUOTAS FOR ALIQUOTAS ACTIVE
AFTER DELETE POSITION 100
AS 
DECLARE VARIABLE IDLOGOPER INTEGER;
DECLARE VARIABLE USUARIO VARCHAR(10);
BEGIN
  /* Se houver log aberto para a conexo corrente ento vincula a operao
     a esse log, do contrrio a varivel ser NULL e o log no vinculado. */
  SELECT MAX(IDLOGOPERACAO), USUARIO
    FROM LOGOPERACAO
   WHERE IDCONNECTION = CURRENT_CONNECTION AND ABERTO = 1
   GROUP BY USUARIO
    INTO :IDLOGOPER, :USUARIO;

  IF (:IDLOGOPER IS NOT NULL) THEN
  BEGIN
    INSERT INTO LOG_ALIQUOTAS (
      TIPOOPERACAO,
      USUARIO,
      DATAHORA,
      IDLOGOPERACAO,
      CODALIQUOTA,
      DESCRICAO
      )
    VALUES (
      'D',
      :USUARIO,
      CURRENT_TIMESTAMP,
      :IDLOGOPER,
      OLD.CODALIQUOTA,
      OLD.DESCRICAO
      );
  END
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRGLOG_INSAGENDA FOR AGENDA ACTIVE
AFTER INSERT POSITION 100
AS 
DECLARE VARIABLE IDLOGOPER INTEGER;
DECLARE VARIABLE USUARIO VARCHAR(10);
BEGIN
  /* Se houver log aberto para a conexo corrente ento vincula a operao
     a esse log, do contrrio a varivel ser NULL e o log no vinculado. */
  SELECT MAX(IDLOGOPERACAO), USUARIO
    FROM LOGOPERACAO
   WHERE IDCONNECTION = CURRENT_CONNECTION AND ABERTO = 1
   GROUP BY USUARIO
    INTO :IDLOGOPER, :USUARIO;

  IF (:IDLOGOPER IS NOT NULL) THEN
  BEGIN
    INSERT INTO LOG_AGENDA (
      TIPOOPERACAO,
      USUARIO,
      DATAHORA,
      IDLOGOPERACAO,
      IDAGENDA,
      NOME,
      TELEFONE,
      FAX
      )
    VALUES (
      'I',
      :USUARIO,
      CURRENT_TIMESTAMP,
      :IDLOGOPER,
      NEW.IDAGENDA,
      NEW.NOME,
      NEW.TELEFONE,
      NEW.FAX
      );
  END
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRGLOG_INSALIQUOTAS FOR ALIQUOTAS ACTIVE
AFTER INSERT POSITION 100
AS 
DECLARE VARIABLE IDLOGOPER INTEGER;
DECLARE VARIABLE USUARIO VARCHAR(10);
BEGIN
  /* Se houver log aberto para a conexo corrente ento vincula a operao
     a esse log, do contrrio a varivel ser NULL e o log no vinculado. */
  SELECT MAX(IDLOGOPERACAO), USUARIO
    FROM LOGOPERACAO
   WHERE IDCONNECTION = CURRENT_CONNECTION AND ABERTO = 1
   GROUP BY USUARIO
    INTO :IDLOGOPER, :USUARIO;

  IF (:IDLOGOPER IS NOT NULL) THEN
  BEGIN
    INSERT INTO LOG_ALIQUOTAS (
      TIPOOPERACAO,
      USUARIO,
      DATAHORA,
      IDLOGOPERACAO,
      CODALIQUOTA,
      DESCRICAO
      )
    VALUES (
      'I',
      :USUARIO,
      CURRENT_TIMESTAMP,
      :IDLOGOPER,
      NEW.CODALIQUOTA,
      NEW.DESCRICAO
      );
  END
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRGLOG_UPDAGENDA FOR AGENDA ACTIVE
AFTER UPDATE POSITION 100
AS 
DECLARE VARIABLE IDLOGOPER INTEGER;
DECLARE VARIABLE USUARIO VARCHAR(10);
BEGIN
  /* Se houver log aberto para a conexo corrente ento vincula a operao
     a esse log, do contrrio a varivel ser NULL e o log no vinculado. */
  SELECT MAX(IDLOGOPERACAO), USUARIO
    FROM LOGOPERACAO
   WHERE IDCONNECTION = CURRENT_CONNECTION AND ABERTO = 1
   GROUP BY USUARIO
    INTO :IDLOGOPER, :USUARIO;

  IF (:IDLOGOPER IS NOT NULL) THEN
  BEGIN
    INSERT INTO LOG_AGENDA (
      TIPOOPERACAO,
      USUARIO,
      DATAHORA,
      IDLOGOPERACAO,
      IDAGENDA,
      NOME,
      TELEFONE,
      FAX
      )
    VALUES (
      'U',
      :USUARIO,
      CURRENT_TIMESTAMP,
      :IDLOGOPER,
      NEW.IDAGENDA,
      NEW.NOME,
      NEW.TELEFONE,
      NEW.FAX
      );
  END
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRGLOG_UPDALIQUOTAS FOR ALIQUOTAS ACTIVE
AFTER UPDATE POSITION 100
AS 
DECLARE VARIABLE IDLOGOPER INTEGER;
DECLARE VARIABLE USUARIO VARCHAR(10);
BEGIN
  /* Se houver log aberto para a conexo corrente ento vincula a operao
     a esse log, do contrrio a varivel ser NULL e o log no vinculado. */
  SELECT MAX(IDLOGOPERACAO), USUARIO
    FROM LOGOPERACAO
   WHERE IDCONNECTION = CURRENT_CONNECTION AND ABERTO = 1
   GROUP BY USUARIO
    INTO :IDLOGOPER, :USUARIO;

  IF (:IDLOGOPER IS NOT NULL) THEN
  BEGIN
    INSERT INTO LOG_ALIQUOTAS (
      TIPOOPERACAO,
      USUARIO,
      DATAHORA,
      IDLOGOPERACAO,
      CODALIQUOTA,
      DESCRICAO
      )
    VALUES (
      'U',
      :USUARIO,
      CURRENT_TIMESTAMP,
      :IDLOGOPER,
      NEW.CODALIQUOTA,
      NEW.DESCRICAO
      );
  END
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_EXCLUSAO_ITEMPERFIL FOR ITEMPERFIL ACTIVE
BEFORE DELETE POSITION 0
AS
begin
  IF (OLD.IDPERFIL = 1) then
    EXCEPTION EXC_EXCLUSAO_PERFIL;
end^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_EXCLUSAO_PERFIL FOR PERFIL ACTIVE
BEFORE DELETE POSITION 0
AS
begin
  IF (OLD.IDPERFIL = 1) then
    EXCEPTION EXC_EXCLUSAO_PERFIL;
end^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_PERDA_ALTERACAO FOR PERDA ACTIVE
BEFORE UPDATE POSITION 0
AS
BEGIN
  UPDATE Produtos SET Estoque = Estoque + OLD.Qtde
    WHERE IdProduto = OLD.CodProduto;
  UPDATE Produtos SET Estoque = Estoque - NEW.Qtde
    WHERE IdProduto = NEW.CodProduto;
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_PERDA_EXCLUSAO FOR PERDA ACTIVE
BEFORE DELETE POSITION 0
AS
BEGIN
  UPDATE Produtos SET Estoque = Estoque + OLD.Qtde
  WHERE IdProduto = OLD.CodProduto;
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_PERDA_INCLUSAO FOR PERDA ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  UPDATE Produtos SET Estoque = Estoque - NEW.Qtde
  WHERE IdProduto = NEW.CodProduto;
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_PROMOCAO_ALTERACAO FOR PROMOCAO ACTIVE
BEFORE UPDATE POSITION 0
AS
BEGIN
  UPDATE Produtos p SET p.PRECO_PROMOCAO = OLD.PRECO
  WHERE p.IDPRODUTO = OLD.PRODUTO;
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_PROMOCAO_EXCLUSAO FOR PROMOCAO ACTIVE
BEFORE DELETE POSITION 0
AS
BEGIN
  update Produtos p set p.PRECO_PROMOCAO = p.VENDA
    where p.IDPRODUTO = OLD.PRODUTO;
  update PRODUTOS p set p.PROMOCAO = 'N'
    where p.IDPRODUTO = OLD.PRODUTO;
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_PROMOCAO_INSERCAO FOR PROMOCAO ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  update Produtos p set p.PRECO_PROMOCAO = new.PRECO
    where p.IDPRODUTO = new.PRODUTO;
  update PRODUTOS p set p.PROMOCAO = 'S'
    where p.IDPRODUTO = new.PRODUTO;
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_SISTEMA_EXCLUSAO FOR SISTEMA ACTIVE
BEFORE DELETE POSITION 0
AS
BEGIN
  IF (OLD.Idsistema = 1) then
    EXCEPTION Exc_Exclusao_Registro;
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TRIG_SISTEMA_INCLUSAO FOR SISTEMA ACTIVE
BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE n INTEGER;
BEGIN
  SELECT COUNT(1) FROM Sistema INTO :n;
  IF (n >= 1) THEN
    EXCEPTION Exc_Inclusao_Registro;
end^
SET TERM ; ^

SET TERM ^ ;
ALTER PROCEDURE STPABRELOGOPERACAO (
    ORIGEM Varchar(80),
    USUARIO Varchar(10) )
AS
BEGIN
  insert into LOGOPERACAO
    (IDLOGOPERACAO,
     IDCONNECTION,
     ORIGEM,
     USUARIO,
     DATAHORA,
     ABERTO)
   values
     (GEN_ID(GENIDLOGOPERACAO, 1),
      CURRENT_CONNECTION,
      :origem,
      :usuario,
      CURRENT_TIMESTAMP,
      1);
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPBAIXACOMPRA (
    CODIGO Integer )
AS
DECLARE VARIABLE VIDPRODUTO INTEGER;
DECLARE VARIABLE VQTDE INTEGER;
DECLARE VARIABLE VCUSTO NUMERIC(13,2);
DECLARE VARIABLE VLUCRO NUMERIC(13,2);
DECLARE VARIABLE VVENDA NUMERIC(13,2);
DECLARE VARIABLE VIDFORN INTEGER;
DECLARE VARIABLE VQTDERECEB INTEGER;
DECLARE VARIABLE VDATARECEB DATE;
BEGIN
  FOR SELECT
        inf.Produto,
        inf.Qtde,
        inf.Custo,
        inf.Lucro,
        inf.Venda,
        nf.Codfornecedor,
        inf.Qtde,
        cast(CURRENT_DATE AS DATE) AS DATA_RECEB
      FROM Itemnotafiscal inf
      LEFT JOIN Notas_Fiscais nf ON (nf.Numero = inf.Numero)
     WHERE (inf.Numero = :Codigo)
      INTO :VIDPRODUTO,
           :VQTDE, 
           :VCUSTO, 
           :VLUCRO, 
           :VVENDA,
           :VIDFORN,
           :VQTDERECEB,
           :VDATARECEB
  DO
  BEGIN
    UPDATE Produtos p SET
      p.Estoque = (p.Estoque + :VQTDE),
      p.Custo = :VCUSTO,
      p.Lucro = :VLUCRO,
      p.Venda = :VVENDA,
      p.Codfornecedor = :VIDFORN,
      p.Qtderecebida = :VQTDERECEB,
      p.Datarecebida = :VDATARECEB
    WHERE p.Idproduto = :VIDPRODUTO;
  END

  UPDATE Notas_Fiscais SET BAIXADO = 'S'
   WHERE NUMERO = :Codigo;

  SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPBAIXAVENDA (
    CODIGO Integer )
AS
DECLARE VARIABLE VIDPRODUTO INTEGER;
DECLARE VARIABLE VQTDE INTEGER;
BEGIN
  FOR SELECT
        iv.Codproduto,
        iv.Qtd
      FROM Itemvenda iv
     WHERE iv.Codigo = :Codigo
      INTO :VIDPRODUTO,
           :VQTDE
  DO
  BEGIN
    UPDATE Produtos p set
      p.Estoque = (p.Estoque - :VQTDE)
    WHERE p.Idproduto = :VIDPRODUTO;
  END

  UPDATE Venda SET BAIXADO = 'S'
   WHERE CODIGO = :Codigo;

  SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPCAIXASPADRAO (
    ID Integer )
AS
BEGIN
  UPDATE CAIXA cx SET cx.Codcaixas = :ID
    WHERE (cx.Codcaixas IS NULL);
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPCONFIGPADRAO (
    COMPUTADOR Varchar(80),
    DIREXP Varchar(150) )
AS
declare variable IDCONTACAIXA integer;
declare variable CAIXA integer;
BEGIN
  select contacheque from configuracao into :caixa;
  select max(codigo)+1 from caixas into :IDCONTACAIXA;

   /* se no tiver conta configurada de cheque ento cadastra */
  IF ((:CAIXA is null) or (:CAIXA = 0)) THEN
  BEGIN
    INSERT INTO CAIXAS(CODIGO, NOME, INATIVO)
    VALUES(:IDCONTACAIXA, 'CHEQUES', 'N');
  END

  /* configuraes padronizadas na primeira abertura do sistema */
  INSERT INTO CONFIGURACAO
  VALUES (gen_id(GENIDCONFIGURACAO,1), :COMPUTADOR, 'S', 'S', 'S', 'S', 'S', 'N', 'S', 'S', 'N', 'S',
          :DIREXP, '563412', 'S', 10, 'N', 1, 1, 1, '563412', 'S', 'S', 'N',
          'S', 'N', 'S', 'S', 'N', 'N', 'N', 'S', 'S', 'N', :IDCONTACAIXA, 'S');
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPDELCAIXA (
    CODIGO Integer )
AS
BEGIN
  DELETE FROM CAIXA WHERE CODCAIXA = :CODIGO;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPDELCP (
    CODIGO Integer )
AS
DECLARE VARIABLE VDOC VARCHAR(20);
DECLARE VARIABLE VPAGA CHAR(1);
BEGIN
  /* busca o documento e se a conta j foi paga */
   SELECT
     cr.Documento,
     cr.Paga
   FROM Contaspagar cr
  WHERE cr.Codigo = :Codigo
   INTO :VDOC,
        :VPAGA;

  /* deleta a conta */
  DELETE FROM Contaspagar cr
   WHERE cr.Codigo = :Codigo;

  /* caso a conta j tenha sido paga, elimina ela do caixa tambm */
  IF (:VPAGA = 'S') THEN
    DELETE FROM Caixa c
     WHERE c.Documento = :VDOC;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPDELCR (
    CODIGO Integer )
AS
DECLARE VARIABLE VDOC VARCHAR(20);
DECLARE VARIABLE VRECDA CHAR(1);
BEGIN
  /* busca o documento e se a conta foi recebida */
   SELECT
     cr.Documento,
     cr.Recda
   FROM Contasreceber cr
  WHERE cr.Codigo = :Codigo
   INTO :VDOC,
        :VRECDA;

  /* exclui o lanamento */
  DELETE FROM Contasreceber cr
   WHERE cr.Codigo = :Codigo;

  /* se o conta j foi recebida, exclui o lanamento no caixa tambm */
  IF (:VRECDA = 'S') THEN
    DELETE FROM Caixa c
     WHERE c.Documento = :VDOC;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPDELDUPLICATA (
    CODIGO Integer )
AS
BEGIN
  DELETE FROM Duplicata dpc WHERE dpc.Idduplicata = :Codigo;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPDELETQPRODUTO (
    CODIGO Varchar(13) )
AS
BEGIN
  DELETE FROM ETIQUETAPROD e WHERE e.CODBARRA = :CODIGO;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPDELORCAMENTO (
    CODIGO Integer )
AS
BEGIN
  DELETE FROM ITEMORCAMENTO io WHERE io.CODIGO = :CODIGO;
  DELETE FROM ORCAMENTO o WHERE o.Codigo = :CODIGO;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPDELVENDA (
    CODIGO Integer )
AS
DECLARE VARIABLE VNUMCHEQUE VARCHAR(20);
BEGIN
  /* deleta regsitro de recebimento da venda */
  delete from RECTOVENDA rv
    where rv.IDVENDA = :CODIGO;

  /* deleta registros do crediario da venda */
  delete from CONTASRECEBER cr
    where cr.VENDA = :CODIGO;

  /* pega o numero do cheque que
     possivelmente possa ser utilizado */
  select
    c.NUMERO
  from CHEQUE c
  where c.VENDA = :CODIGO
  into :VNUMCHEQUE;

  /* deleta registro do caixa da venda */
  delete from CAIXA cx
    where ((cx.DOCUMENTO like '%V'||cast(:CODIGO as varchar(20))||'%')
       or  (cx.DOCUMENTO like :VNUMCHEQUE));

  /* delete cheques da venda */
  delete from CHEQUE  cq
   where cq.VENDA = :CODIGO;

  /* cancela a venda */
  update Venda v set
    v.Cancelado = 'S',
    V.Concluida = 'N'
   where v.Codigo = :Codigo;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPDESMARCAPROMOCAO
AS
BEGIN
  delete from PROMOCAO pro
  where pro.FIM < CURRENT_DATE;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPESTORNACOMPRA (
    CODIGO Integer )
AS
DECLARE VARIABLE VIDPRODUTO INTEGER;
DECLARE VARIABLE VQTDE INTEGER;
DECLARE VARIABLE VNUMCHEQUE VARCHAR(20);
BEGIN
  FOR SELECT
        inf.Produto,
        inf.QTDE
      FROM Itemnotafiscal inf
     WHERE inf.Numero = :CODIGO
      INTO :VIDPRODUTO,
           :VQTDE
  DO
  BEGIN
    UPDATE Produtos p set
      p.Estoque = (p.Estoque - :VQTDE)
     WHERE p.Idproduto = :VIDPRODUTO;
  END

  /* deleta regsitro de pagamento da compra */
  DELETE FROM Pagtocompra pc
   WHERE pc.Idcompra = :Codigo;

  /* deleta registros do contas a pagar da compra */
  DELETE FROM Contaspagar cp
   WHERE cp.Compra = :Codigo;

  SELECT
    c.Numero
    FROM Cheque c
   WHERE c.Compra = :Codigo
    INTO :VNUMCHEQUE;

  /* deleta registro do caixa da compra */
  DELETE FROM CAIXA cx
   WHERE ((cx.DOCUMENTO like '%C'||cast(:CODIGO as varchar(20))||'%')
      OR  (cx.DOCUMENTO like :VNUMCHEQUE));

  /* delete cheques da venda */
  DELETE FROM Cheque cq
   WHERE cq.Compra = :Codigo;

  /* coloca a venda como NO concluda */
  UPDATE Notas_Fiscais nf set
    nf.Concluida = 'N',
    nf.Baixado   = 'N'
   WHERE nf.Numero = :Codigo;

  SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPESTORNAVENDA (
    CODIGO Integer )
AS
DECLARE VARIABLE VNUMCHEQUE VARCHAR(20);
DECLARE VARIABLE VCODPRODUTO INTEGER;
DECLARE VARIABLE VQTDE INTEGER;
begin
  for select
        iv.CODPRODUTO,
        iv.QTD
      from ITEMVENDA iv
      where iv.CODIGO = :CODIGO
      into :VCODPRODUTO,
           :VQTDE
  do
  begin
    update PRODUTOS p set
      p.ESTOQUE = (p.ESTOQUE + :VQTDE)
    where p.IDPRODUTO = :VCODPRODUTO;
  end

  /* deleta regsitro de recebimento da venda */
  delete from RECTOVENDA rv
    where rv.IDVENDA = :CODIGO;

  /* deleta registros do crediario da venda */
  delete from CONTASRECEBER cr
    where cr.VENDA = :CODIGO;

  select
    c.NUMERO
  from CHEQUE c
  where c.VENDA = :CODIGO
  into :VNUMCHEQUE;

  /* deleta registro do caixa da venda */
  delete from CAIXA cx
    where ((cx.DOCUMENTO like '%V'||cast(:CODIGO as varchar(20))||'%')
       or  (cx.DOCUMENTO like :VNUMCHEQUE));

  /* delete cheques da venda */
  delete from CHEQUE  cq
   where cq.VENDA = :CODIGO;

  /* coloca a venda como NO concluda */
  update VENDA v set
    v.Concluida = 'N',
    v.Baixado   = 'N'
   where v.CODIGO = :CODIGO;

  SUSPEND;
end^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPFECHALOGOPERACAO
AS
BEGIN
  update LOGOPERACAO
     set ABERTO = 0
   where IDCONNECTION = CURRENT_CONNECTION
     and ABERTO = 1;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPGETCLIENTEANIVER (
    TIPO Integer,
    DIAINI Integer,
    DIAFIM Integer,
    MES Integer,
    ANO Integer,
    DATA1 Date,
    DATA2 Date )
RETURNS (
    NOME Varchar(50),
    DATANASC Date,
    ENDERECO Varchar(50),
    CIDADE Varchar(50),
    BAIRRO Varchar(50),
    CEP Varchar(20),
    FONE Varchar(20) )
AS
BEGIN
   if (:TIPO = 0) then -- por dia mes e ano
   begin
     for select
           wec.NOME,
           wec.DATA,
           wec.ENDERECO,
           wec.CIDADE,
           wec.BAIRRO,
           wec.CEP,
           cli.TELEFONE
         from VIEWENDERECOCLIENTES wec
         left join CLIENTES cli on (wec.Codigo = cli.Codcliente)
        where (extract(month from DATA) = :MES)
          and (extract(day from DATA) between :DIAINI and :DIAFIM)
          and ((:ANO = -1) or (:ANO IS NULL))
         into :NOME,
              :DATANASC,
              :ENDERECO,
              :CIDADE,
              :BAIRRO,
              :CEP,
              :FONE
     do
       suspend;
   end
   else if (:TIPO = 1) then --entre datas
   begin
     for select
           wec.NOME,
           wec.DATA,
           wec.ENDERECO,
           wec.CIDADE,
           wec.BAIRRO,
           wec.CEP,
           cli.TELEFONE
         from VIEWENDERECOCLIENTES wec
        inner join CLIENTES cli on (wec.Codigo = cli.Codcliente)
        where (DATA between :DATA1 and :DATA2)
         into :NOME,
              :DATANASC,
              :ENDERECO,
              :CIDADE,
              :BAIRRO,
              :CEP,
              :FONE
     do
       suspend;
   end
end^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPGETID (
    FIELDNAME Varchar(31),
    TABLENAME Varchar(31) )
RETURNS (
    ID Integer )
AS
begin
  execute statement 'select max('||:FIELDNAME||') from '||:TABLENAME into :ID;
  ID = ID + 1;
  suspend;
end^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPINSCAIXA (
    CONTA Integer,
    DATA Date,
    DESCRICAO Varchar(80),
    DOCUMENTO Varchar(20),
    TIPO Char(1),
    VALOR Numeric(13,4) )
AS
DECLARE VARIABLE ID INTEGER;
BEGIN
  EXECUTE PROCEDURE STPGETID('CODCAIXA', 'CAIXA') RETURNING_VALUES :ID;
  INSERT INTO CAIXA(CODCAIXA, CODCAIXAS, DATA, DESCRICAO, DOCUMENTO, TIPO, VALOR, EXCLUIR)
  VALUES(:ID, :CONTA, :DATA, :DESCRICAO, :DOCUMENTO, :TIPO, :VALOR, 'N');
  SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPINSCHEQUE (
    PIDBANCO Integer,
    PIDCLIENTE Integer,
    PIDFORN Integer,
    PBANDAMAGNETICA Varchar(35),
    PAGENCIA Varchar(20),
    PCONTA Varchar(20),
    PNUMERO Varchar(20),
    PDATAEMISSAO Date,
    PBOMPARA Date,
    PVALOR Numeric(13,4),
    PVENDA Integer,
    PCOMPRA Integer,
    PREPASSADO Char(1),
    PDATABAIXADO Date )
AS
DECLARE VARIABLE ID INTEGER;
BEGIN
  /* id do cheque */
  EXECUTE PROCEDURE STPGETID('IDCHEQUE', 'CHEQUE') RETURNING_VALUES :ID;

  /* lana o cheque */
  INSERT INTO CHEQUE(IDCHEQUE, IDBANCO, IDCLIENTE, IDFORN, BANDAMAGNETICA, AGENCIA, CONTA,
    NUMERO, DATAEMISSAO, BOMPARA, VALOR, VENDA, COMPRA, REPASSADO, DATABAIXADO)
  VALUES(:ID, :PIDBANCO, :PIDCLIENTE, :PIDFORN, :PBANDAMAGNETICA, :PAGENCIA, :PCONTA, 
    :PNUMERO, :PDATAEMISSAO, :PBOMPARA, :PVALOR, :PVENDA, :PCOMPRA, :PREPASSADO, :PDATABAIXADO);

  SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPPAGTOCOMPRA (
    IDCOMPRA Integer,
    DATAPAGTO Date,
    FORMAPAGTO Varchar(20),
    VALORPAGO Numeric(13,2) )
AS
DECLARE VARIABLE TOTALCOMPRA FLOAT;
DECLARE VARIABLE RESTO FLOAT;
DECLARE VARIABLE IDPAGTOCOMPRA INTEGER;
DECLARE VARIABLE RESTOATUAL FLOAT;
BEGIN

  SELECT nf.TOTAL FROM NOTAS_FISCAIS nf WHERE NUMERO = :IDCOMPRA INTO :TOTALCOMPRA;
  SELECT MAX(IDPAGTOCOMPRA) FROM PAGTOCOMPRA INTO :IDPAGTOCOMPRA;
  SELECT MIN(VALORRESTO) FROM PAGTOCOMPRA WHERE IDCOMPRA = :IDCOMPRA INTO :RESTOATUAL;

  IF ((:TOTALCOMPRA IS NULL) OR (:TOTALCOMPRA < 0)) THEN
    TOTALCOMPRA = 0;

  IF ((:RESTOATUAL IS NULL) OR (:RESTOATUAL < 0)) THEN
    RESTOATUAL = 0;

  IF ((:IDPAGTOCOMPRA IS NULL) OR (:IDPAGTOCOMPRA < 0)) THEN
    IDPAGTOCOMPRA = 0;
  IDPAGTOCOMPRA = IDPAGTOCOMPRA + 1;

  /* se o restoatual for zero, entende que ainda no foi feito nenhum pagamento */
  IF (:RESTOATUAL > 0) THEN
    RESTO = (:RESTOATUAL - :VALORPAGO);
  ELSE
    RESTO = :TOTALCOMPRA - (:VALORPAGO + :RESTOATUAL);

  IF ((:RESTO < 0) or (:RESTO IS NULL)) THEN
    RESTO = 0;

  insert into PAGTOCOMPRA
    (IDPAGTOCOMPRA, IDCOMPRA, DATAPAGTO, FORMAPAGTO, VALORPAGO, VALORRESTO)
  values(:IDPAGTOCOMPRA, :IDCOMPRA, :DATAPAGTO, :FORMAPAGTO, :VALORPAGO, :RESTO);

  /* s conclui a compra caso no tenha mais resto,ou o valor a pagar for igual
     ao total da compra */
  IF ((:VALORPAGO = :TOTALCOMPRA) OR (:RESTO = 0)) THEN
    UPDATE NOTAS_FISCAIS SET CONCLUIDA = 'S'
    WHERE NUMERO = :IDCOMPRA;

  SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPPRODUTOSVENCIDOS (
    DATAVENC Date,
    IDUN Integer,
    IDGRUPO Integer,
    IDFORNECEDOR Integer )
RETURNS (
    CODBARRA Varchar(13),
    PRODUTO Varchar(50),
    DATAVENCIMENTO Date,
    UNIDADE Varchar(20),
    GRUPO Varchar(50),
    FORNECEDOR Varchar(50),
    PRECOCUSTO Numeric(13,2) )
AS
BEGIN
    FOR SELECT
      p.CODBARRA,
      p.DESCRICAO,
      p.Datavalidade,
      u.DESCRICAO,
      g.DESCRICAO,
      f.FANTAZIA,
      p.CUSTO
    FROM PRODUTOS p
    LEFT JOIN UNIDADES u ON (u.Codunidade = p.Codunidade)
    LEFT JOIN GRUPOS g ON (g.CODGRUPO = p.CODGRUPO)
    LEFT JOIN FORNECEDORES f ON (f.CODFORNECEDOR = p.CODFORNECEDOR)
    WHERE ((:IDUN = -1)or(p.Codunidade = :IDUN))
    AND ((:IDGRUPO = -1)or(p.Codgrupo = :IDGRUPO))
    AND ((:IDFORNECEDOR = -1)or(p.Codfornecedor = :IDFORNECEDOR))
    AND ((p.Datavalidade >= :DATAVENC))
    INTO :CODBARRA,
         :PRODUTO,
         :DATAVENCIMENTO,
         :UNIDADE,
         :GRUPO,
         :FORNECEDOR,
         :PRECOCUSTO
    DO
    BEGIN
      SUSPEND;
    END
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPRECTOVENDA (
    IDVENDA Integer,
    DATARECTO Date,
    FORMARECTO Varchar(20),
    VALORRECDO Numeric(13,2) )
AS
DECLARE VARIABLE TOTALVENDA FLOAT;
DECLARE VARIABLE RESTO FLOAT;
DECLARE VARIABLE IDRECTOVENDA INTEGER;
DECLARE VARIABLE RESTOATUAL FLOAT;
BEGIN

  SELECT v.TOTAL FROM VENDA v WHERE CODIGO = :IDVENDA INTO :TOTALVENDA;
  SELECT MAX(IDRECTOVENDA) FROM RECTOVENDA INTO :IDRECTOVENDA;
  SELECT MIN(VALORRESTO) FROM RECTOVENDA WHERE IDVENDA = :IDVENDA INTO :RESTOATUAL;

  if ((:TOTALVENDA is null) or (:TOTALVENDA < 0)) then
    TOTALVENDA = 0;

  if ((:IDRECTOVENDA is null) or (:IDRECTOVENDA < 0)) then
    IDRECTOVENDA = 0;
  IDRECTOVENDA = IDRECTOVENDA + 1;

  if ((:RESTOATUAL is null) or (:RESTOATUAL < 0)) then
    RESTOATUAL = 0;

  /* se o restoatual for zero, entende que ainda no foi feito nenhum recebimento */
  IF (:RESTOATUAL > 0) THEN
    RESTO = (:RESTOATUAL - :VALORRECDO);
  ELSE
    RESTO = :TOTALVENDA - (:VALORRECDO + :RESTOATUAL);

  IF ((:RESTO <= 0) or (:RESTO IS NULL)) THEN
    RESTO = 0;

  insert into RECTOVENDA
    (IDRECTOVENDA, IDVENDA, DATARECTO, FORMARECTO, VALORRECDO, VALORRESTO)
  values(:IDRECTOVENDA, :IDVENDA, :DATARECTO, :FORMARECTO, :VALORRECDO, :RESTO);

  /* s conclui a venda caso no tenha mais resto ou o valor a receber for igual
     ao total da venda */
  IF ((:VALORRECDO = :TOTALVENDA) OR (:RESTO = 0)) THEN
    UPDATE VENDA SET CONCLUIDA = 'S'
    WHERE CODIGO = :IDVENDA;

  SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPRELCAIXAMESANO (
    MES Integer,
    ANO Integer,
    PORDEM Char(1) )
RETURNS (
    CODIGO Integer,
    DATA Date,
    DESCRICAO Varchar(80),
    DOCUMENTO Varchar(20),
    TIPO Char(1),
    VALOR Numeric(13,2),
    TOTALCREDITOS Numeric(13,2),
    TOTALDEBITOS Numeric(13,2),
    TOTALSALDO Numeric(13,2),
    TOTAL Numeric(13,2) )
AS
BEGIN
  /* Total creditos */
  SELECT SUM(VALOR)FROM VIEWRELCAIXA
         WHERE TIPO = 'C'
         AND EXTRACT(MONTH FROM DATA) = :MES
         AND EXTRACT(YEAR FROM DATA) = :ANO
         INTO :TOTALCREDITOS;

         if (TOTALCREDITOS IS NULL) then
           TOTALCREDITOS = 0;

  /* Total debitos */
  SELECT SUM(VALOR)FROM VIEWRELCAIXA
         WHERE TIPO = 'D'
         AND EXTRACT(MONTH FROM DATA) = :MES
         AND EXTRACT(YEAR FROM DATA) = :ANO
         INTO :TOTALDEBITOS;

         if (TOTALDEBITOS IS NULL) then
           TOTALDEBITOS = 0;

  /* Saldo */
  TOTALSALDO = TOTALCREDITOS - TOTALDEBITOS;

    FOR SELECT
       CODIGO,
       DATA,
       DESCRICAO,
       DOCUMENTO,
       TIPO,
       VALOR
     FROM VIEWRELCAIXA
     WHERE EXTRACT(MONTH FROM DATA) = :MES
     AND EXTRACT(YEAR FROM DATA) = :ANO
     ORDER BY
    
     case when :pordem = 'L' then
       CODIGO end,
     case when :pordem = 'D' then
       DATA end
    
     INTO
       :CODIGO,
       :DATA,
       :DESCRICAO,
       :DOCUMENTO,
       :TIPO,
       :VALOR
    DO
     SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPRELCAIXATIPOCONTA (
    PDATAINI Date,
    PDATAFIM Date,
    PTIPOCONTA Char(1),
    PORDEM Char(1) )
RETURNS (
    CODIGO Integer,
    TOTAL Numeric(13,2),
    DATA Date,
    DESCRICAO Varchar(80),
    DOCUMENTO Varchar(20),
    TIPO Char(1),
    VALOR Numeric(13,2) )
AS
BEGIN

  /* Total pelas datas e tipo de conta */
  SELECT
     SUM(VALOR)
    FROM VIEWRELCAIXA
   WHERE ((TIPO = :PTIPOCONTA) OR (:ptipoconta = 'T'))
     AND DATA BETWEEN :PDATAINI AND :PDATAFIM
    INTO :TOTAL;

  if (TOTAL IS NULL) then
    TOTAL = 0;

   FOR SELECT
      CODIGO,
      DATA,
      DESCRICAO,
      DOCUMENTO,
      TIPO,
      VALOR
    FROM VIEWRELCAIXA
    WHERE ((TIPO = :PTIPOCONTA) OR (:ptipoconta = 'T'))
    AND DATA BETWEEN :PDATAINI AND :PDATAFIM

    ORDER BY
      CASE WHEN :pordem = 'L' THEN CODIGO END,
      case WHEN :pordem = 'D' THEN DATA END

    INTO
      :CODIGO, 
      :DATA,
      :DESCRICAO, 
      :DOCUMENTO, 
      :TIPO, 
      :VALOR
   DO
     SUSPEND;
end^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPRESTOCOMPRA (
    PIDCOMPRA Integer )
RETURNS (
    RESTO Numeric(13,2) )
AS
DECLARE VARIABLE PAGO FLOAT;
DECLARE VARIABLE TOTAL_COMPRA FLOAT;
DECLARE VARIABLE COUNT_PAGTO SMALLINT;
begin
  TOTAL_COMPRA = 0;
  COUNT_PAGTO  = 0;
  RESTO        = 0;
  PAGO         = 0;

  select nf.TOTAL from NOTAS_FISCAIS nf where
  nf.NUMERO = :PIDCOMPRA into :TOTAL_COMPRA;

  select count(1) from PAGTOCOMPRA pc where
  pc.IDCOMPRA = :PIDCOMPRA into :COUNT_PAGTO;

  select
    sum(VALORPAGO)
  from PAGTOCOMPRA
  where IDCOMPRA = :PIDCOMPRA
  into :PAGO;

  if ((:COUNT_PAGTO is null)or(:COUNT_PAGTO <= 0)) then
    RESTO = TOTAL_COMPRA;
  else
    RESTO = (TOTAL_COMPRA - PAGO);

  if (RESTO < 0) then
    RESTO = 0;

  suspend;
end^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPRESTOVENDA (
    PIDVENDA Integer )
RETURNS (
    RESTO Numeric(13,2) )
AS
DECLARE VARIABLE RECDO FLOAT;
DECLARE VARIABLE COUNT_RECTO SMALLINT;
DECLARE VARIABLE TOTAL_VENDA FLOAT;
begin
  TOTAL_VENDA = 0;
  COUNT_RECTO = 0;
  RESTO       = 0;
  RECDO       = 0;

  select ve.TOTAL from VENDA ve where
  ve.CODIGO = :PIDVENDA into :TOTAL_VENDA;

  select count(1) from RECTOVENDA rv where
  rv.IDVENDA = :PIDVENDA into :COUNT_RECTO;

  select
    sum(VALORRECDO)
  from RECTOVENDA
  where IDVENDA = :PIDVENDA
  into :RECDO;

  if ((:COUNT_RECTO is null)or(:COUNT_RECTO <= 0)) then
    RESTO = TOTAL_VENDA;
  else
    RESTO = (TOTAL_VENDA - RECDO);

  if (RESTO < 0) then
    RESTO = 0;

  suspend;
end^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPSITUACAOCLIENTE (
    CODIGO Integer )
RETURNS (
    CLIENTE Varchar(80),
    LIMITECLIENTE Numeric(13,2),
    DATACADASTRO Date,
    TOTALCONTAS Numeric(13,2),
    TOTALCONTASVENCIDAS Numeric(13,2),
    PRIMEIROVENCIMENTO Date,
    DIASATRASO Integer )
AS
BEGIN

  /*Seleciona os valores da tabela clientes*/
  SELECT Nome, Limite, Cadastro FROM Clientes
   WHERE CodCliente = :Codigo
    INTO :CLIENTE, :LIMITECLIENTE, :DATACADASTRO;

  IF (LimiteCLIENTE IS NULL) THEN
    LimiteCLIENTE = 0;

  SELECT SUM(Total) FROM CONTASRECEBER
   WHERE (RECDA = 'N')
     AND (Cliente = :CODIGO)
    INTO :TOTALCONTAS;

  IF (TOTALCONTAS IS NULL) THEN
    TOTALCONTAS = 0;

  SELECT SUM(Total) FROM CONTASRECEBER
   WHERE (RECDA = 'N')
     AND (Cliente = :CODIGO)
     AND (Vencimento < CURRENT_TIMESTAMP)
    INTO :TOTALCONTASVENCIDAS;

  IF (TOTALCONTASVENCIDAS IS NULL) THEN
    TOTALCONTASVENCIDAS = 0;

  SELECT MIN(Vencimento) FROM CONTASRECEBER /* Primeiro vencto */
   WHERE (RECDA = 'N')
     AND (Cliente = :CODIGO)
    INTO :PRIMEIROVENCIMENTO;

  DIASATRASO = (CURRENT_DATE - :PRIMEIROVENCIMENTO);

  if (DIASATRASO IS NULL) then
    DIASATRASO = 0;

  SUSPEND;
END^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE STPVENDACOMISSAO (
    VENDEDOR Integer,
    DATAINI Date,
    DATAFIM Date )
RETURNS (
    CODPRODUTO Integer,
    DESCRICAO Varchar(150),
    QTD Integer,
    TOTAL Numeric(13,2),
    COMISSAO Numeric(13,2) )
AS
BEGIN
  FOR
    SELECT Produtos.IDPRODUTO, Produtos.DESCRICAO, SUM(ItemVenda.QTD),
      SUM(ItemVenda.TOTAL), SUM(ItemVenda.VALORCOMISSAO)
    FROM Venda, ItemVenda, Produtos
    WHERE
      Venda.IDVENDEDOR = :Vendedor AND
      Venda.DATA BETWEEN :DataIni AND :DataFim AND
      Venda.Concluida = 'S' AND
      ItemVenda.CODIGO = Venda.CODIGO AND
      Produtos.IDPRODUTO = ItemVenda.CODPRODUTO
    GROUP BY Produtos.IDPRODUTO, Produtos.Descricao
    ORDER BY Produtos.Descricao
    INTO :CodProduto, :Descricao, :Qtd, :Total, :Comissao
  DO
    SUSPEND;
END^
SET TERM ; ^


ALTER TABLE CAIXA ADD CONSTRAINT FK_CAIXA_CAIXAS
  FOREIGN KEY (CODCAIXAS) REFERENCES CAIXAS (CODIGO) ON UPDATE SET NULL ON DELETE SET NULL;
CREATE INDEX IDX_CAIXA_DATA ON CAIXA (DATA);
ALTER TABLE CHEQUE ADD CONSTRAINT FK_CHEQUE_BANCO
  FOREIGN KEY (IDBANCO) REFERENCES BANCO (IDBANCO) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE CHEQUE ADD CONSTRAINT FK_CHEQUE_CLIENTE
  FOREIGN KEY (IDCLIENTE) REFERENCES CLIENTES (CODCLIENTE) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE CHEQUE ADD CONSTRAINT FK_CHEQUE_COMPRA
  FOREIGN KEY (COMPRA) REFERENCES NOTAS_FISCAIS (NUMERO) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE CHEQUE ADD CONSTRAINT FK_CHEQUE_FORN
  FOREIGN KEY (IDFORN) REFERENCES FORNECEDORES (CODFORNECEDOR) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE CHEQUE ADD CONSTRAINT FK_CHEQUE_VENDA
  FOREIGN KEY (VENDA) REFERENCES VENDA (CODIGO) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE CLIENTES ADD CONSTRAINT FK_CLIENTES_CIDADE
  FOREIGN KEY (CODCIDADE) REFERENCES CIDADES (CODCIDADE);
ALTER TABLE CONFIGURACAO ADD CONSTRAINT FK_CONFIGURACAO_ALIQUOTA
  FOREIGN KEY (ALIQUOTAPADRAO) REFERENCES ALIQUOTAS (CODALIQUOTA) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE CONFIGURACAO ADD CONSTRAINT FK_CONFIGURACAO_CAIXA
  FOREIGN KEY (CAIXAPADRAO) REFERENCES CAIXAS (CODIGO) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE CONFIGURACAO ADD CONSTRAINT FK_CONFIGURACAO_CONTACAIXA
  FOREIGN KEY (CONTACHEQUE) REFERENCES CAIXAS (CODIGO) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE CONTASPAGAR ADD ATRASO COMPUTED BY (
    CASE
       WHEN Paga = 'N' AND VENCIMENTO < CURRENT_DATE THEN
         CURRENT_DATE - VENCIMENTO /* A receber em atraso */
       WHEN Paga = 'S' AND VENCIMENTO < DataPagto THEN
         DataPagto - VENCIMENTO /* Recebida em atraso */
       ELSE
         0
    END);
ALTER TABLE CONTASPAGAR ADD VALORJURO COMPUTED BY (CAST(Valor * Juro * Atraso / 100 / 30 AS FLOAT));
ALTER TABLE CONTASPAGAR ADD TOTAL COMPUTED BY (CAST(Valor + ValorJuro AS FLOAT));
ALTER TABLE CONTASPAGAR ADD TOTALPAGO COMPUTED BY (CAST(CapitalPago + JuroPago AS FLOAT));
ALTER TABLE CONTASPAGAR ADD CONSTRAINT FK_CONTASPAGAR_CONTA
  FOREIGN KEY (IDCONTA) REFERENCES CAIXAS (CODIGO);
ALTER TABLE CONTASPAGAR ADD CONSTRAINT FK_CONTASPAGAR_FORN
  FOREIGN KEY (FORNECEDOR) REFERENCES FORNECEDORES (CODFORNECEDOR);
ALTER TABLE CONTASRECEBER ADD ATRASO COMPUTED BY (
    CASE
       WHEN Recda = 'N' AND VENCIMENTO < CURRENT_DATE THEN
         CURRENT_DATE - VENCIMENTO
       WHEN Recda = 'S' AND VENCIMENTO < DataRecto THEN
         DataRecto - VENCIMENTO
       ELSE
         0
    END);
ALTER TABLE CONTASRECEBER ADD VALORJURO COMPUTED BY (CAST(Valor * Juro * Atraso / 100 / 30 AS FLOAT));
ALTER TABLE CONTASRECEBER ADD TOTAL COMPUTED BY (CAST(Valor + ValorJuro AS FLOAT));
ALTER TABLE CONTASRECEBER ADD TOTALRECDO COMPUTED BY (CAST(CapitalRecdo + JuroRecdo AS FLOAT));
ALTER TABLE CONTASRECEBER ADD CONSTRAINT FK_CONTASRECEBER_CLIENTE
  FOREIGN KEY (CLIENTE) REFERENCES CLIENTES (CODCLIENTE);
ALTER TABLE CONTASRECEBER ADD CONSTRAINT FK_CONTASRECEBER_CONTA
  FOREIGN KEY (IDCONTA) REFERENCES CAIXAS (CODIGO);
ALTER TABLE DUPLICATA ADD CONSTRAINT FK_DUPLICATA_CIDADE
  FOREIGN KEY (IDCIDADE) REFERENCES CIDADES (CODCIDADE);
ALTER TABLE EMPRESA ADD CONSTRAINT FK_EMPRESA_CIDADE
  FOREIGN KEY (IDCIDADE) REFERENCES CIDADES (CODCIDADE);
ALTER TABLE ENVELOPE ADD CONSTRAINT FK_ENVELOPE_CIDADE
  FOREIGN KEY (IDCIDADE) REFERENCES CIDADES (CODCIDADE);
ALTER TABLE FORNECEDORES ADD CONSTRAINT FK_FORNECEDORES_CIDADE
  FOREIGN KEY (CIDADE) REFERENCES CIDADES (CODCIDADE);
ALTER TABLE ITEMNOTAFISCAL ADD CONSTRAINT FK_ITEMNOTAFISCAL_ALIQUOTA
  FOREIGN KEY (ALIQUOTA) REFERENCES ALIQUOTAS (CODALIQUOTA);
ALTER TABLE ITEMNOTAFISCAL ADD CONSTRAINT FK_ITEMNOTAFISCAL_NOTAFISCAL
  FOREIGN KEY (NUMERO) REFERENCES NOTAS_FISCAIS (NUMERO);
ALTER TABLE ITEMNOTAFISCAL ADD CONSTRAINT FK_ITEMNOTAFISCAL_PRODUTO
  FOREIGN KEY (PRODUTO) REFERENCES PRODUTOS (IDPRODUTO);
ALTER TABLE ITEMORCAMENTO ADD CONSTRAINT FK_ITEMORCAMENTO_ORCAM
  FOREIGN KEY (CODIGO) REFERENCES ORCAMENTO (CODIGO);
ALTER TABLE ITEMORCAMENTO ADD CONSTRAINT FK_ITEMORCAMENTO_PRODUTO
  FOREIGN KEY (CODPRODUTO) REFERENCES PRODUTOS (IDPRODUTO);
ALTER TABLE ITEMPERFIL ADD CONSTRAINT FK_ITEMPERFIL_PERFIL
  FOREIGN KEY (IDPERFIL) REFERENCES PERFIL (IDPERFIL) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE ITEMVENDA ADD CONSTRAINT FK_ITEMVENDA_PRODUTO
  FOREIGN KEY (CODPRODUTO) REFERENCES PRODUTOS (IDPRODUTO);
ALTER TABLE ITEMVENDA ADD CONSTRAINT FK_ITEMVENDA_VENDA
  FOREIGN KEY (CODIGO) REFERENCES VENDA (CODIGO);
CREATE INDEX IX_LOG_AGENDA_DU ON LOG_AGENDA (DATAHORA,USUARIO);
CREATE INDEX IX_LOG_AGENDA_LO ON LOG_AGENDA (IDLOGOPERACAO);
CREATE INDEX IX_LOG_AGENDA_PK ON LOG_AGENDA (IDAGENDA);
CREATE INDEX IX_LOG_AGENDA_U ON LOG_AGENDA (USUARIO);
CREATE INDEX IX_LOG_ALIQUOTAS_DU ON LOG_ALIQUOTAS (DATAHORA,USUARIO);
CREATE INDEX IX_LOG_ALIQUOTAS_LO ON LOG_ALIQUOTAS (IDLOGOPERACAO);
CREATE INDEX IX_LOG_ALIQUOTAS_PK ON LOG_ALIQUOTAS (CODALIQUOTA);
CREATE INDEX IX_LOG_ALIQUOTAS_U ON LOG_ALIQUOTAS (USUARIO);
ALTER TABLE NOTAS_FISCAIS ADD CONSTRAINT FK_NOTAS_FISCAIS_FORN
  FOREIGN KEY (CODFORNECEDOR) REFERENCES FORNECEDORES (CODFORNECEDOR);
ALTER TABLE ORCAMENTO ADD CONSTRAINT FK_ORCAMENTO_CLIENTE
  FOREIGN KEY (CODCLIENTE) REFERENCES CLIENTES (CODCLIENTE);
ALTER TABLE ORCAMENTO ADD CONSTRAINT FK_ORCAMENTO_VENDEDOR
  FOREIGN KEY (IDVENDEDOR) REFERENCES VENDEDOR (IDVENDEDOR);
ALTER TABLE PAGTOCOMPRA ADD CONSTRAINT FK_PAGTOCOMPRA_COMPRA
  FOREIGN KEY (IDCOMPRA) REFERENCES NOTAS_FISCAIS (NUMERO) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE PERDA ADD CONSTRAINT FK_PERDA_PRODUTO
  FOREIGN KEY (CODPRODUTO) REFERENCES PRODUTOS (IDPRODUTO);
ALTER TABLE PRODUTOS ADD VALOR_ESTOQUE COMPUTED BY (
    CASE
      WHEN (ESTOQUE > 0) AND (CUSTO > 0) THEN
        CAST(ESTOQUE * CUSTO AS FLOAT)
      ELSE
        CAST(0 AS FLOAT)
    END);
ALTER TABLE PRODUTOS ADD CONSTRAINT FK_PRODUTOS_ALIQUOTA
  FOREIGN KEY (IDALIQUOTA) REFERENCES ALIQUOTAS (CODALIQUOTA);
ALTER TABLE PRODUTOS ADD CONSTRAINT FK_PRODUTOS_FORN
  FOREIGN KEY (CODFORNECEDOR) REFERENCES FORNECEDORES (CODFORNECEDOR);
ALTER TABLE PRODUTOS ADD CONSTRAINT FK_PRODUTOS_GRUPO
  FOREIGN KEY (CODGRUPO) REFERENCES GRUPOS (CODGRUPO);
ALTER TABLE PRODUTOS ADD CONSTRAINT FK_PRODUTOS_UNIDADE
  FOREIGN KEY (CODUNIDADE) REFERENCES UNIDADES (CODUNIDADE);
ALTER TABLE PROMOCAO ADD CONSTRAINT FK_PROMOCAO_PRODUTO
  FOREIGN KEY (PRODUTO) REFERENCES PRODUTOS (IDPRODUTO) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE RECTOVENDA ADD CONSTRAINT FK_RECTOVENDA_VENDA
  FOREIGN KEY (IDVENDA) REFERENCES VENDA (CODIGO) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE USUARIOS ADD CONSTRAINT FK_USUARIOS_PERFIL
  FOREIGN KEY (IDPERFIL) REFERENCES PERFIL (IDPERFIL) ON UPDATE SET NULL ON DELETE SET NULL;
ALTER TABLE VENDA ADD CONSTRAINT FK_VENDA_CLIENTE
  FOREIGN KEY (CODCLIENTE) REFERENCES CLIENTES (CODCLIENTE);
ALTER TABLE VENDA ADD CONSTRAINT FK_VENDA_VENDEDOR
  FOREIGN KEY (IDVENDEDOR) REFERENCES VENDEDOR (IDVENDEDOR);
GRANT EXECUTE
 ON PROCEDURE STPABRELOGOPERACAO TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPBAIXACOMPRA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPBAIXAVENDA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPCAIXASPADRAO TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPCONFIGPADRAO TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPDELCAIXA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPDELCP TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPDELCR TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPDELDUPLICATA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPDELETQPRODUTO TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPDELORCAMENTO TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPDELVENDA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPDESMARCAPROMOCAO TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPESTORNACOMPRA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPESTORNAVENDA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPFECHALOGOPERACAO TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPGETCLIENTEANIVER TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPGETID TO PROCEDURE STPCONFIGPADRAO;

GRANT EXECUTE
 ON PROCEDURE STPGETID TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPINSCAIXA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPINSCHEQUE TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPPAGTOCOMPRA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPPRODUTOSVENCIDOS TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPRECTOVENDA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPRELCAIXAMESANO TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPRELCAIXATIPOCONTA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPRESTOCOMPRA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPRESTOVENDA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPSITUACAOCLIENTE TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE STPVENDACOMISSAO TO  SYSDBA;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON AGENDA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ALIQUOTAS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON BANCO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CAIXA TO  SYSDBA WITH GRANT OPTION;

GRANT INSERT
 ON CAIXAS TO PROCEDURE STPCONFIGPADRAO;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CAIXAS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CFOP TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CHEQUE TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CIDADES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CLIENTES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CONFIGDUPLICATA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CONFIGNOTA TO  SYSDBA WITH GRANT OPTION;

GRANT INSERT, SELECT
 ON CONFIGURACAO TO PROCEDURE STPCONFIGPADRAO;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CONFIGURACAO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CONFIGURACAOGLOBAL TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CONTASPAGAR TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CONTASRECEBER TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON DUPLICATA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON EMPRESA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ENVELOPE TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ETIQUETA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ETIQUETAPROD TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON FORNECEDORES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON GRUPOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ITEMNOTAFISCAL TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ITEMORCAMENTO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ITEMPERFIL TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ITEMVENDA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON LOGERRO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON LOGOPERACAO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON LOG_AGENDA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON LOG_ALIQUOTAS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON MENSAGEM TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON NOTAS_FISCAIS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON ORCAMENTO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON PAGTOCOMPRA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON PERDA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON PERFIL TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON PRODUTOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON PROMOCAO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON RECIBO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON RECTOVENDA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON SISTEMA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON UNIDADES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON USUARIOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VENDA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VENDEDOR TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWAGENDA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWCAIXA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWCAIXAS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWCAIXASATIVOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWCHEQUE TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWEMPRESA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWENDERECOCLIENTES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWETIQUETACLIENTE TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWFICHACLIENTE TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWFK TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWFORNECEDORES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWITEMVENDA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWPERDAS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWPESQUISAFONE TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWPESQUISAPRECO TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWPK TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWPRODUTOSMINIMOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELCAIXA TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELCAIXACAIXAS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELCAIXATODOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELCLIENTES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELCP TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELCPATRASADOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELCR TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELCRATRASADOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELFORN TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELNPCR TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWRELPRODUTOS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON VIEWVENDA TO  SYSDBA WITH GRANT OPTION;

